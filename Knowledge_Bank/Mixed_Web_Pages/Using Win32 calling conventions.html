<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<link rel="stylesheet" type="text/css" href="Using%20Win32%20calling%20conventions_files/unixwiz.css">
<link rel="shortcut icon" href="http://unixwiz.net/favicon.ico">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://unixwiz.net/techtips/techtips.rss">
<meta name="version" content="$Id: //websites/unixwiz/unixwiz.net/webroot/techtips/win32-callconv.web#18 $">
<!-- RSS description = programmer point of view. -->
<!-- RSS pubDate = 2004/01/27 -->
<!-- Host: cs.unixwiz.net -->
<style type="text/css">
TT	{ font-weight: bold; }
/*the table of declarations & symbol types */
.ldcl	{ font-family: "Courier New", Courier; }
.lsym	{ font-family: "Courier New", Courier;
	  font-weight: bold;
	  color: red;
	  padding-left: 24pt; }
.red	{ color: red; }
.boldred { color: red;  font-weight: bold; }
</style>
<title>Using Win32 calling conventions</title>
</head>
<body>
<div id="warning">
  <h2>Does this site look plain?</h2>
  <p>This site uses advanced css techniques</p>
</div>
<div id="logo">
 <a href="http://unixwiz.net/">
  <img src="Using%20Win32%20calling%20conventions_files/unixwiz-logo-140x80.gif" alt="[Steve Friedl Logo]">
 </a>
</div>
<div id="pageheader">
<h1> Steve Friedl's Unixwiz.net Tech Tips </h1>
<h2> Using Win32 calling conventions </h2>
</div>
<div id="navmenu">
  <ul>
<li><a href="http://unixwiz.net/"> Home </a> </li>
<li><a href="http://unixwiz.net/contact"> Contact </a> </li>
<li><a href="http://unixwiz.net/about/"> About </a> </li>
<li><a href="http://unixwiz.net/techtips/"> TechTips </a> </li>
<li><a href="http://unixwiz.net/tools/"> Tools&amp;Source </a> </li>
<li><a href="http://unixwiz.net/evo/"> Evo Payroll </a> </li>
<li><a href="http://unixwiz.net/research/"> Research </a> </li>
<li><a href="http://unixwiz.net/3b2.html"> AT&amp;T 3B2 </a> </li>
<li><a href="http://unixwiz.net/advisories.html"> Advisories </a> </li>
<li><a href="http://unixwiz.net/news.html"> News/Pubs </a> </li>
<li><a href="http://unixwiz.net/literacy.html"> Literacy </a> </li>
<li><a href="http://unixwiz.net/voting/"> Calif.Voting </a> </li>
<li><a href="http://unixwiz.net/personal/"> Personal </a> </li>
<li><a href="http://blog.unixwiz.net/"> Tech Blog </a> </li>
<li><a href="http://smokeblog.unixwiz.net/"> SmokeBlog </a> </li>
</ul>
</div>
<div id="pagecontent">

<p>
When writing code for the Win32 platform, most developers don't pay
attention to selecting a "calling convention", and in most cases it
doesn't really matter much. But as systems get larger and split into
more modules (especially when third-party modules are to be included),
this becomes something that cannot really be ignored.
</p>

<div id="toc">
<center> Table of Contents </center>
<ul>
<li> <a href="#conv"> Calling Conventions </a> </li>
<li> <a href="#decor"> Linker symbol name decorations </a> </li>
<li> <a href="#compiler"> Won't the compiler catch this? </a> </li>
<li> <a href="#when"> When does it matter? </a> </li>
<li> <a href="#dlls"> Calling functions exported from DLLs </a> </li>
<li> <a href="#largesys"> Building bigger systems </a> </li>
</ul>
</div>

<p>
In this Tech Tip, we discuss what the MSVC calling conventions are,
why to choose one over the other, and "big system" considerations that
may not be obvious.
</p>

<br clear="all">

<h1 id="conv"> Calling Conventions </h1>

<p>
Traditionally, C function calls are made with the caller pushing some
parameters onto the stack, calling the function, and then popping the
stack to clean up those pushed arguments.
</p>

<pre class="codeblock">/* example of __cdecl */
push arg1
push arg2
push arg3
call function
add  sp,12        // effectively "pop; pop; pop"
</pre>

<p>
It turns out that Microsoft compilers on Windows (and probably most others)
support not just this convention, but two others as well. The technical
details are found <a href="http://msdn.microsoft.com/library/en-us/vccore98/html/_core_calling_conventions_topics.asp">at
Microsoft's MSDN site</a>, but we'll touch on them here as well.
</p>

<p>
The default convention — shown above — is known as <tt>__cdecl</tt>.
</p>

<p>
The other most popular convention is <tt>__stdcall</tt>. In it
the parameters are again pushed by the caller, but the stack
is cleaned up <em>by the callee</em>. It is the standard convention
for Win32 API functions (as defined by the WINAPI macro in
&lt;windows.h&gt;), and it's also sometimes called the
"Pascal" calling convention.
</p>

<pre class="codeblock">/* example of __stdcall */
push arg1
push arg2
push arg3
call function
// no stack cleanup - callee does this
</pre>

<p>
This looks like a minor technical detail, but if there is a disagreement
on how the stack is managed between the <b>caller</b> and the <b>callee</b>,
the stack will be destroyed in a way that is unlikely to be recovered.
</p>

<div class="important">
A mismatch in calling convention is <em>catastrophic</em>
for a running program.
</div>

<p>
At first this seems like a not-that-interesting distinction (to many it is
in fact not-that-interesting), but there are several implications that arise
when considering one or the other.
</p>

<div class="sidebar">
<center> Argument push order? </center>
<p>
There is no single "correct" order in which a compiler pushes arguments
on the stack: some go left to right, while others go right to left. This
is determined by the author of the compiler, often influenced by the
underlying architecture.
</p>
<p>
Our general observation is that machines with
a stack that grows down push from right to left, while up-growing stacks
push left to right.
</p>
<p>
But unlike calling conventions, which the user controls, argument push
order is defined by the compiler and not subject to the kinds of mismatches
we discuss here. Portable code <b>never</b> relies on argument push order.
</p>
</div>

<p>
We'll note that there is also a <tt>__fastcall</tt> convention that uses registers,
but we don't believe it's really that useful in the general case — the save
and restore of the registers often removes any speed benefit of using the
register for arg passing. We'll only touch on it in passing.
</p>

<ul>

<li>Since <tt>__stdcall</tt> does stack cleanup, the (very tiny) code
to perform this task is found in only one place, rather than being
duplicated in every caller as it is in <tt>__cdecl</tt>. This makes the
code very slightly smaller, though the size impact is only visible
in large programs.
</li>

<li>Variadic functions like <b>printf()</b> are almost impossible to get right
with <tt>__stdcall</tt>, because only the caller <em>really</em> knows how many
arguments were passed in order to clean them up. The <em>callee</em> can make
some good guesses (say, by looking at a format string), but the stack
cleanup would have to be determined by the actual logic of the function,
not the calling-convention mechanism itself. Hence only <tt>__cdecl</tt>
supports variadic functions so that the caller can do the cleanup.
</li>

<li>
There isn't really a "right or wrong" with respect to which one is
best, but it is positively fatal to "mix and match". The general
principle is "the stack-cleanup must match the arg-pushing", and
this only happens when caller and callee know what the other is
doing. Calling a function with the "wrong" convention will destroy
the stack.
</li>

</ul>

<br clear="all">

<h1 id="decor"> Linker symbol name decorations </h1>

<p>
As mentioned in a bullet point above, calling a function with the "wrong"
convention can be disastrous, so Microsoft has a mechanism to avoid this
from happening. It works well, though it can be maddening if one does
not know what the reasons are.
</p>

<p>
They have chosen to resolve this by encoding the calling convention
into the low-level function names with extra characters (which are
often called "decorations"), and these are treated as unrelated names
by the linker. The default calling convention is <tt>__cdecl</tt>, but
each one can be requested explicitly with the /G? parameter to the
compiler.
</p>

<dl class="defnlist">
<dt><tt>__cdecl</tt> &nbsp; (<b><tt>cl <u>/Gd</u> ...</tt></b>)
</dt>
<dd>All function names of this type are prefixed with an underscore,
and the number of parameters does not really matter because the caller
is responsible for stack setup and stack cleanup. It <em>is</em> possible
for a caller and callee to be confused over the number of parameters
actually passed, but at least the stack discipline is maintained properly.
</dd>

<dt><tt>__stdcall</tt> &nbsp; (<b><tt>cl <u>/Gz</u> ...</tt></b>)
</dt>
<dd>These function names are prefixed with an underscore and appended
with the number of bytes of parameters passed. By this mechanism, it's
not possible to call a function with the "wrong" type, or even with the
wrong number of parameters.
</dd>

<dt><tt>__fastcall</tt> &nbsp; (<b><tt>cl <u>/Gr</u> ...</tt></b>)
</dt>
<dd>These function names <em>start</em> with an <tt>@</tt> sign and are suffixed
with the @parameter count, much like <tt>__stdcall</tt>.
</dd>
</dl>

<p>
Examples:
</p>

<table class="standard">
<tbody><tr><th>Declaration    </th>
    <th>decorated name </th> </tr>
<tr> <td class="ldcl"> void <span class="red">__cdecl</span>&nbsp;&nbsp;&nbsp; foo(void);
     </td>
     <td class="lsym"> _foo </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__cdecl</span>&nbsp;&nbsp;&nbsp; foo(int a); </td>
    <td class="lsym"> _foo	</td>
</tr>

<tr><td class="ldcl"> void <span class="red">__cdecl</span>&nbsp;&nbsp;&nbsp; foo(int a, int b);
    </td>
    <td class="lsym"> _foo </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__stdcall</span>&nbsp; foo(void);
    </td>
    <td class="lsym"> _foo@0
    </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__stdcall</span>&nbsp; foo(int a);
    </td>
    <td class="lsym"> _foo@4
    </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__stdcall</span>&nbsp; foo(int a, int b);
    </td>
    <td class="lsym"> _foo@8
    </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__fastcall</span> foo(void);
    </td>
    <td class="lsym"> @foo@0
    </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__fastcall</span> foo(int a);
    </td>
    <td class="lsym"> @foo@4
    </td>
</tr>

<tr><td class="ldcl"> void <span class="red">__fastcall</span> foo(int a, int b);
    </td>
    <td class="lsym"> @foo@8
    </td>
</tr>
</tbody></table>

<p>
We'll note that the <em>decorated</em> names are never visible
to a C program:
they are strictly a linker facility, and the linker will never resolve one
kind of reference with the "wrong" one.
</p>

<p>
We can see this in action with a simple program that declares — but does not
define — several functions that are not found by the linker.
</p>

<pre class="codeblock">C&gt; <span class="red"><b>type testfile.c</b></span>
extern void <b>__stdcall func1</b>(int a);
extern void <b>__stdcall func2</b>(int a, int b, double d);
extern void <b>__cdecl   func3</b>(int b);
extern void <b>__cdecl   func4</b>(int a, int b, double d);

int __cdecl main(int argc, char **argv)
{
        <b>func1</b>(1);

        <b>func2</b>(2, 3, 4.);

        <b>func3</b>(5);

        <b>func4</b>(6, 7, 8.0);

        return 0;
}

C&gt; <span class="red"><b>cl /nologo testfile.c</b></span>
testfile.c
testfile.obj : error LNK2001: unresolved external symbol <b>_func1@4</b>  <i>... __stdcall</i>
testfile.obj : error LNK2001: unresolved external symbol <b>_func2@16</b> <i>... __stdcall</i>
testfile.obj : error LNK2001: unresolved external symbol <b>_func3</b>    <i>... __cdecl</i>
testfile.obj : error LNK2001: unresolved external symbol <b>_func4</b>    <i>... __cdecl</i>
testfile.exe : fatal error LNK1120: 4 unresolved externals
</pre>

<p>
Note that since a <tt>double</tt> variable takes eight bytes
(not four like an <tt>int</tt>),
the three-parameter <tt>func2()</tt> is <tt>...@16</tt>
instead of <tt>...@12</tt>. But both
of the <tt>__cdecl</tt> functions are undecorated in this manner.
</p>

<h1 id="compiler"> But doesn't the compiler catch this? </h1>

<p>
Yes, but the calling-convention decorations are solving a somewhat
narrower problem than function prototypes do.
</p>

<p>
C++ has always supported, and ANSI C introduced, "function prototypes",
which allow one to describe the parameters of a function in a declaration
(previously, only the return type was part of a declaration). When a
function is actually called, it's compared with the declaration, and a
warning issued:
</p>

<pre class="codeblock">/* somefile.c */

extern int  <b>foo(int a)</b>; // prototype
...
n = <b>foo(1, 2, 3)</b>;  // mismatch! bad parameter count!
</pre>

<p>
Here, the compiler expects the <b>foo()</b> function to take just one
parameter, and when it see a few more (or with the wrong type), it
objects. The Microsoft calling-conventions would add nothing to this.
</p>

<p>
But when the linker enters the picture, it's possible to see cases where
this will arise. Consider two files, one that <i>uses</i> a function and
the other that <i>defines</i> it:
</p>

<pre class="codeblock">/* in file1.c */                  /* in file2.c */

extern int <b>__cdecl foo</b>(int);      int <b>__stdcall foo</b>(int a)
                                  {
...                                   ....
n = foo(1);                       }
</pre>

<p>
Since the compiler never looks at the two <i>source</i> files together,
it could never detect that there has been a mismatch in the calling
conventions used.  The resulting code, if linked, would destroy the stack.
</p>

<p>
Before one lambasts the programmer for making such a foolish mistake,
consider that the <i>default</i> calling convention is usually <tt>__cdecl</tt>,
so even if the file1.c example omitted the declaration for <tt>foo()</tt>,
it would still default upon first use to <tt>__cdecl</tt>. This is a different
(but very common) oversight.
</p>

<p>
In a small project, the example shown is highly contrived, but as
systems get larger, this situation arises more often. It's common to
use a third-party library (which exports many functions), and one cannot
always tell which compiler flags were used by the library builder.
</p>

<p>
It's at this point where we get to the real reason for the
calling-convention decorations. It's not to keep a programmer from
calling a function with the wrong number (or type) of arguments:
</p>

<div class="quote">Important!</div>
<div class="qbody">
Calling-convention symbol decorations exist <u>only</u> to maintain stack discipline
</div>

<h1 id="when"> When does it matter? </h1>

<p>
In most cases, it makes no difference either which calling convention is
used by default throughout the program, or what the convention is on any
particular function, but there are a few exceptions of note when using
other than <tt>__cdecl</tt> for the default.
</p>

<ul>
<li>The function <tt>main()</tt> (and the wide version <tt>wmain()</tt>)
must always be <tt>__cdecl</tt>.
</li>

<li>The function <tt>WinMain()</tt> — the starting point for GUI programs
— is always <tt>__stdcall</tt>, though this is pre-declared by the
<tt>&lt;windows.h&gt;</tt> include file to make this more or less automatic.
</li>

<li>
<p>Variadic ("printf-like") functions are <tt>__cdecl</tt> even if declared
otherwise (e.g., the calling convention keyword is ignored). We are
surprised that the compiler does not issue a warning against this misuse:
</p>

<blockquote><pre>int <tt>__stdcall</tt> myprintf(const char *fmt, ...); // <b>it's really __cdecl</b>
</pre></blockquote>
</li>

<li><p>Some library functions take addresses of <i>other</i> functions as
parameters, and these must be matched properly. A common example is
<b>qsort</b>, which takes a "compare" function as the last parameter,
and this function must be <tt>__cdecl</tt>.
</p>

<pre class="codeblock">extern void __cdecl qsort( void *base, size_t num, size_t width,
          <span class="red"><b>int (__cdecl *compare )(const void *, const void *) )</b></span>;
....
int <span class="red"><tt>__stdcall</tt></span> mycompare(const void *p1, const void *p2)
{
    // compare here
}
....
qsort(base, n, width, <span class="red"><b>mycompare</b></span>);    // <b>ERROR</b> - mismatch
</pre>

<p>
We'll note here that the calling convention of the <b>qsort</b> function itself
doesn't enter into this — it's the convention of the <i>parameter</i> to <b>qsort</b>
that does.
</p>

<p>
This function-address-as-parameter issue also comes up with signal handlers.
</p>
</li>

</ul>

<h1 id="dlls"> Calling functions exported from DLLs</h1>

<p>
When one builds a system from scratch, it's usually straightforward
to coordinate the calling conventions (often at the <tt>Makefile</tt>
level), but an added twist arises when using
<abbr title="Dynamic Link Libraries">DLLs</abbr> provided by third
parties, especially if it's written in a different language.
</p>

<p>
If the <em>only</em> item provided is the .DLL itself, without an
associated import library and header file, one must associate the
calling convention with the function pointer itself, and the compiler
will generally be powerless to provide any real help.
</p>

<p>
For illustration, we'll work with a hypothetical barcode
library <tt>BARCODE.DLL</tt>, and it provides two functions that
we fetch by name, and then call via a pointer:
</p>

<pre class="codeblock">typedef BOOL (<span class="red">__stdcall</span> *INITFUNCTION)(BOOL);
typedef int  (<span class="red">__stdcall</span> *DRAWFUNCTION)(int x, int y, const char *label);

HINSTANCE hInst = LoadLibrary("barcode.dll");

INITFUNCTION pfInit = (INITFUNCTION)GetProcAddress(hInst, "Init");
DRAWFUNCTION pfDraw = (DRAWFUNCTION)GetProcAddress(hInst, "Draw");

(*pfInit)(TRUE);

(*pfDraw)(1, 1, "12345");
(*pfDraw)(1, 2, "67890");
</pre>

<p>
It's important to note that using a calling convention in the
<tt>typedef</tt>, one must <em>match</em> the convention
used by the actual code, and a mismatch here will be both
undetectible by the compiler, and fatal at runtime.
</p>

<p> There is
no real substitute for checking the documentation provided by
the supplier of the library.
</p>

<h1 id="largesys"> Building bigger systems </h1>

<p>
As mentioned, smaller programs really just don't care much about this,
but when systems get larger, or when third-party libraries enter the
picture, it becomes necessary to be aware of calling-convention issues
(particularly on an inter-module basis). This is further complicated if
the software in question must be ported to non-Windows platforms that
have no notion of calling conventions.

</p>

<p>
Even when one has the source to a third-party package (say, the excellent
<a href="http://www.net-snmp.org/">NET-SNMP library</a>), one may still
not be too excited about diving into the build system. Though UNIX build
systems are almost always created based on "Makefiles", Windows builds
often use "project files" that are somewhat less transparent and more
<i>ad hoc</i>.
</p>

<p>
Our preference is to use <tt>__stdcall</tt> when possible, but it's less
important "which convention to use" than it is "all conventions match". We
also don't like to <i>insist</i> that all parts be built the same way, so
a library could be built mainly with one while the application another.
</p>

<p>
We'll start with the library, and with the first guidline:
</p>

<div class="quote"> Rule #1: </div>
<div class="qbody">
Library headers should explicitly name a calling
convention <i>everywhere</i> — Do not rely on the default.
</div>

<p>
When a library header includes the calling convention on every
function, the default value won't ever be considered, so the client
application can use whatever it likes for its convention. The
</p>

<p>
For a Win32-only library, it's straightforward enough to simply
note the calling convention on every function:
</p>

<pre class="codeblock">/* mylibrary.h */

extern void * <span class="boldred">__stdcall</span> circalloc(size_t n);
extern char * <span class="boldred">__stdcall</span> circdup(const char *s);
extern char * <span class="boldred">__cdecl</span>   circfmt(const char *fmt, ...);
extern BOOL   <span class="boldred">__stdcall</span> set_inherit_handle(BOOL bInherit, HANDLE h);
extern void   <span class="boldred">__stdcall</span> init_timestamp(void);
extern size_t <span class="boldred">__stdcall</span> sprintf_timestamp(char *obuf);

typedef void <span class="boldred">__stdcall</span> FAILHANDLER(int, const char *, const char *);
extern FAILHANDLER * <span class="boldred">__stdcall</span> set_fail_handler(FAILHANDLER *pHdlr);
...
</pre>

<p>
<i>Typedefs</i> carry the calling convention (implicit or explicit)
along with the type information for function pointers, and in our
simple library, we've done this with the <b>FAILHANDLER</b> typedef.
</p>

<p>
In practice it's not strictly necessary to mark the function <i>definitions</i>
with the calling-convention keywords, because if the definition is seen
in the presense of the keyword-endowed declaration from the header file,
it overrides the default.
</p>

<pre class="codeblock">/* somefile.c */

extern void <span class="boldred">__stdcall</span> foo1(void);
..
void foo1(void)      // <b>OK</b> - <tt>__stdcall</tt> taken from the declaration just seen
{
   ...
}


extern void <span class="boldred">__stdcall</span> foo2(void);
...
void <span class="boldred">__cdecl</span> foo2(void) // <b>ERROR</b> - clashes with <tt>__stdcall</tt> above
{
   ...
}


extern void foo3(void);   // presume <span class="boldred">__cdecl</span>
...
void <span class="boldred">__stdcall</span> foo3(void) // <b>ERROR</b> - clashes with presumed <tt>__cdecl</tt>
{
   ...
}
</pre>

<p>
Most libraries also have internal functions that are not exported or
visible to the users, and these need not have the calling conventions
noted.  The idea is that since the library is built as a whole in one
big step, all the parts will share the same default convention even if
it's different from how other unrelated modules are built. As long as
these functions are not visible to the outside, their conventions are
a private matter.
</p>

<p>
Where this gets trickier is when the library will be used by non-Win32
platforms, almost all of which treat <tt>__stdcall</tt> and related keywords
as <b>syntax errors</b>.
</p>

<div class="quote">Rule #2:</div>
<div class="qbody">
Use the C preprocessor and a portability-related header file to make
this work seamlesly on non-MSVC platforms.
</div>

<p>
We generally create a <b>"portable.h"</b> header file that contains this
(and many other) definitions related to portability. Since the calling
conventions are meaningless on non-Windows compilers, all that's required
to support them is to make them go away.
</p>

<pre class="codeblock">#ifndef _WIN32
#  define __cdecl    /* nothing */
#  define __stdcall  /* nothing */
#  define __fastcall /* nothing */
#endif /* _WIN32 */
</pre>

<p>
This elides these keywords anytime they are seen on a non-Windows
platform, though developers using compilers other than Microsoft Visual
C may need to tune the definitions a bit.
</p>

<p>
We've found it most helpful to define our libraries such that they all
have a <b>"portable.h"</b> header file that all others can include to help
iron out some of these compiler and platform differences. "Portability"
extends to far beyond just the calling conventions, though this is a
habit that only "experience" can inform.
</p>

<p>
As an aside, we'll encourage those taking this approach to add support
for the GNU C compiler <tt>__attribute__</tt> facility, which can be used
to provide high-level information tagging that the compiler uses to
perform better error checking. Though the details of <tt>__attribute__</tt>
itself are not pertinent to our discussion, the "making it work for a
non-GNU compiler" fits squarely in our <b>"portable.h"</b> scheme:
</p>

<p>
• <a href="http://unixwiz.net/techtips/gnu-c-attributes.html">Unixwiz.net Tech Tip
- Using GNU C __attribute__</a>
</p>

<p>
An important goal is that the calling convention applied to the functions
<em>at library compile time</em> must be the same that the client application
sees when the header files is used. A contorted <b>"portable.h"</b> file that
allows for (say) <tt>__stdcall</tt> to be defined sometimes and not other times
on the same platform is asking for trouble.
</p>

<hr>

<p>
Note: We've been taken to task for the use of this <b>portable.h</b>
technique, suggesting that trying to preprocess out a reserved word may
break things. We've never seen this in spite of years of portable coding,
but it does seem prudent to consider this if using compilers outside
the mainstream.
</p>

<ol>
<li> It's been suggested that we should key off of <b>_MSC_VER</b> instead
of <b>_WIN32</b> </li>
<li> Rather than #define away reserved words, it's been suggested that portable
code should instead invent new symbols and use those in the code, relying on
the macros to either insert the calling convention keywords, or not. We're
not convinced, but we're not prepared to dismiss this out of hand.
</li>
</ol>

<div id="navmore">
  <a href="http://unixwiz.net/techtips/index.html"> More Tech Tips </a>
</div>

</div>
<div id="pagefooter">
  <span class="bottomright"> </span>
  <div class="pagefootercontent">
    <a href="http://unixwiz.net/"> Home </a>
	<span class="divbrick"> &nbsp; </span> 
    <a href="http://unixwiz.net/contact.html">Stephen J. Friedl</a>
    <span class="divbrick"> &nbsp;</span>
    Software Consultant
    <span class="divbrick"> &nbsp;</span>
    Orange County, CA USA
    <span class="divbrick"> &nbsp;</span>
    <img src="Using%20Win32%20calling%20conventions_files/steve-email.gif" alt="[Steve's Email]">
<span class="divbrick"> &nbsp; </span>
  <a href="http://unixwiz.net/techtips/techtips.rss">
    <img src="Using%20Win32%20calling%20conventions_files/feed-icon-14x14.png" alt="[RSS Feed available]" width="14" height="14" border="0">
  </a>
  </div>
</div>

</body></html>