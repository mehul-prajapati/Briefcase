<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" dir="ltr" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Using Serial Peripheral Interface (SPI) for Fast Serial Data Exchange</title>
<meta name="robots" content="noodp,noydir">
<meta name="author" content="Paul Clifford, ">
<meta name="description" content="Using the SPI (serial peripheral interface) for fast serial data exchange and multi-drop serial communications between the PDQ Board and peripheral devices including analog to digital and digital to analog converters, real time clocks, sensors and actuators.">
<meta name="keywords" content="serial peripheral interface spi, using spi bus for serial data exchange, spi bus pins, sck mosi, connecting spi bus, software drivers for spi, managing multiple devices spi channels, summary hcs12/9s12 spi, how to use spi for, synchronous serial data exchange 9s12 hcs12 development board single board computer, instrument controller peripheral devices, bidirectional synchronous serial interface, convenient connecting pdq single board computer, sbc variety peripheral devices">
<link rel="contents" href="http://www.mosaic-industries.com/embedded-systems/site-map" title="Table of Contents, Index">
<meta name="generator" content="DW Mosaic template">
<meta name="robots" content="index,follow">
<meta name="revision" content="2014-03-13T10:05:49+0000">
<link rel="search" type="application/opensearchdescription+xml" href="http://www.mosaic-industries.com/embedded-systems/lib/exe/opensearch.php" title="Mosaic Documentation Web">
<link rel="start" href="http://www.mosaic-industries.com/embedded-systems/">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://www.mosaic-industries.com/embedded-systems/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://www.mosaic-industries.com/embedded-systems/feed.php?mode=list&amp;ns=sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://www.mosaic-industries.com/embedded-systems/_export/xhtml/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface">
<link rel="alternate" type="text/plain" title="Wiki Markup" href="http://www.mosaic-industries.com/embedded-systems/_export/raw/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface">
<link rel="canonical" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface">
<link rel="stylesheet" media="screen" type="text/css" href="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/css_003.css">
<link rel="stylesheet" media="all" type="text/css" href="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/css_002.css">
<link rel="stylesheet" media="print" type="text/css" href="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/css.css">
<script async="" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/cbgapi.loaded_1"></script><script async="" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/cbgapi.loaded_0"></script><script gapi_processed="true" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plusone.js" async="" type="text/javascript"></script><script src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript"><!--//--><![CDATA[//><!--
var NS='sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control';var JSINFO = {"id":"sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control:spi-serial-peripheral-interface","namespace":"sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control"};
//--><!]]></script>
<script type="text/javascript" charset="utf-8" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/js.php"></script><style type="text/css" media="screen"><!--/*--><![CDATA[/*><!--*/ .folded.hidden { display: none; } .folder .indicator { visibility: visible; } /*]]>*/--></style>
<script type="text/javascript" charset="utf-8" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/menu.js"></script>
<script type="text/javascript"><!--//--><![CDATA[//><!--
var indexmenu_ID='sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface'
//--><!]]></script>
<link rel="shortcut icon" href="http://www.mosaic-industries.com/embedded-systems/lib/tpl/mosaic/images/favicon.gif">
<style type="text/css">.block.public{display:block;}.block.local{display:none;}.inline.public {display:inline;}.inline.local{display:none;}div.dokuwiki.export{width:720px;}
  #center__col{min-width:620px;}
  .pg_both{margin:0 162px 0 224px;padding:0 2px 2px 2px;}
  .pg_only{padding:0 0 2px 0;}
  .pg_no_left{margin:0 162px 0 0;padding:0 2px 2px 0;}
  .pg_no_right{margin:0 0 0 224px;padding:0 0 2px 2px;}
  #left__col{width:224px;}
  #right__col{width:162px;margin-left:-162px;}
  div.sb{max-height:480px;}
  .wboth{min-width:1024px;}
  .wneither{ min-width:634px;}
  .wleft{min-width:860px;}
  .wright{min-width:798px;}</style>
<script type="text/javascript">var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-8685403-1']);_gaq.push(['_trackPageview']);(function() {var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);})();</script>
</head>
<body>
<div class="dokuwiki">
<div id="body__width" class="wleft">
<header id="body__banner"><div id="m__header">
<div style="float:right;"></div>
<div id="m__logo">
<a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" title="Mosaic Documentation Web"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/logo.png" alt="Documents, tutorials, how-to guides, product manuals, specifications -- programming single board computers, instrument controllers and microcontrollers for measurement, control, SCADA, instrumentation and industrial automation" title="Documents, tutorials, how-to guides, product manuals, specifications -- programming single board computers, instrument controllers and microcontrollers for measurement, control, SCADA, instrumentation and industrial automation"></a><span id="m__logoline"><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" accesskey="h" title="Documents, tutorials, how-to guides, product manuals, specifications -- programming single board computers, instrument controllers and microcontrollers for measurement, control, SCADA, instrumentation and industrial automation">Mosaic Documentation Web</a></span><span id="tag__line">Providing Embedded Computers for Instruments &amp; Automation since 1985</span></div></div>
<div id="__bcs">
<div class="breadcrumbs"><div class="emptybtn">&nbsp;</div><span class="bchead">Visited pages:&nbsp;</span><span class="curid"><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface" class="breadcrumbs" title="sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control:spi-serial-peripheral-interface" rel="nofollow">Serial Peripheral Interface (SPI)</a></span></div>
<div class="breadcrumbs"><div id="btn__TLC" class="ltglclose" title="Show/hide the left sidebar">&nbsp;</div><nav><span class="bchead">Current path: </span><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" class="wikilink1" title="microcontroller">All Docs</a> \ <a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/microcontroller" class="wikilink1" title="sbc-single-board-computers:microcontroller">Single Board Computers</a> \ <a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/microcontroller" class="wikilink1" title="sbc-single-board-computers:freescale-hcs12-9s12-c-language:microcontroller">PDQ Board</a> \ <a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller" class="wikilink1" title="sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control:microcontroller">PDQ Board Users Guide</a> \ <span class="curid"><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface" class="wikilink1" title="sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control:spi-serial-peripheral-interface">Serial Peripheral Interface (SPI)</a></span></nav></div>

</div>
</header>
<div id="bdy__content"><div id="m__cols"><div id="center__col"><div style="margin-left: 224px;" id="center__content" class="pg_no_right">
<div id="m__pgcontents"><div id="content__shdwbox" class="rounded tintedtop pgtop"><div class="tlbr_holder" id="tlbr_placeholder"></div>
<div id="__origin">
<div class="linkhere"><span class="popup_link inline action16 link" title="Help others find us by linking to this page" onclick="msc_positionPopup(this)" id="_725047002">Link here</span><span><!--<div id="pop_725047002" class="popup"><span class="insitupopup"><span class="popup_close"><a onclick="this.parentNode.parentNode.parentNode.style.display='none';">&nbsp; &nbsp; &nbsp;</a></span><span class="popup_content"><p>To link to this page, copy the following code and paste it into your web page. Feel free to customize it for your page.</p><div class="block wrap"><pre class="code" style="color:#521;font-size:100%">&lt;p&gt;&lt;a href=&quot;http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface&quot; target=&quot;_blank&quot; title=&quot;Single board computers (SBCs) microcontrollers &amp; embedded systems RTOS for instrumentation and industrial automation&quot;&gt;Serial Peripheral Interface (SPI)&lt;/a&gt;&lt;/p&gt;</pre></div></span></span></div>--></span><div class="sharebtn"><div class="gplusone"><div id="___plusone_0" style="text-indent: 0px; margin: 0px; padding: 0px; background: none repeat scroll 0% 0% transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 24px; height: 15px;"><iframe title="+1" data-gapiattached="true" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/fastbutton.html" name="I0_1394802102498" id="I0_1394802102498" vspace="0" tabindex="0" style="position: static; top: 0px; width: 24px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 15px;" marginwidth="0" marginheight="0" hspace="0" scrolling="no" width="100%" frameborder="0"></iframe></div></div></div></div>
<article class="content" itemscope="" itemtype="http://schema.org/Article">
<meta itemprop="mainContentOfPage" content="true">
<meta itemprop="name" content="Using Serial Peripheral Interface (SPI) for Fast Serial Data Exchange">
<meta itemprop="headline" content="Serial Peripheral Interface (SPI)">
<meta itemprop="description" content="Using the SPI (serial peripheral interface) for fast serial data exchange and multi-drop serial communications between the PDQ Board and peripheral devices including analog to digital and digital to analog converters, real time clocks, sensors and actuators.">
<meta itemprop="author" content="Paul Clifford, ">
<meta itemprop="editor" content="Paul Clifford, , Mosaic Industries, Inc.">
<meta itemprop="publisher" content="Mosaic Industries, Inc.">
<meta itemprop="copyrightHolder" content="Mosaic Industries, Inc.">



<h1 class="sectionedit1" id="serial-peripheral-interface-spi">Serial Peripheral Interface (SPI)</h1><div class="level1"><div class="block tagline">How to use the <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> for fast, synchronous serial data exchange between the <abbr title="Multitasking single board embedded computers, or touchscreen controllers, using the Freescale 9S12 / HCS12 microcontroller, (MC9S12A512 / MC9S12DP512)">PDQ</abbr> Board and peripheral devices</div><hr>

<p></p><div class="inlinetoc"><!-- TOC START -->
<div class="toc">
<div style="cursor: pointer;" class="tocheader toctoggle" id="toc__header"><span class="toc_close" style="cursor: pointer;" id="toc__toggle"><span>−</span></span>Page Contents</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#using-the-spi-bus-for-fast-serial-data-exchange" class="toc">Using the SPI bus for fast serial data exchange</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#spi-bus-pinssck-mosi-and-miso" class="toc">SPI bus pins: SCK, MOSI, and MISO</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#connecting-to-the-spi-bus" class="toc">Connecting to the SPI bus</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#software-drivers-for-the-spi" class="toc">Software drivers for the SPI</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#managing-multiple-devices-on-spi-channel-0" class="toc">Managing multiple devices on SPI channel 0</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#managing-multiple-devices-on-spi-channels-1-and-2" class="toc">Managing multiple devices on SPI channels 1 and 2</a></span></div></li>
</ul>
</li>
<li class="level1"><div class="li"><span class="li"><a href="#summary-of-the-hcs129s12-spi" class="toc">Summary of the HCS12/9S12 SPI</a></span></div></li></ul>
</div>
</div>
<!-- TOC END -->
</div><p>
</p>
<p>The Serial Peripheral Interface, SPI, is a fast synchronous serial 
interface.  It provides a convenient means of connecting the PDQ Single 
Board Computer (<abbr title="Single Board Computers, used as embedded systems - Mosaic's SBCs are complete computers, built on a single small form factor printed circuit board (PCB), with a microcontroller, Flash and RAM memory, RS232/RS485 serial communications and SPI, and numerous timer controlled digital and analog I/O ports.">SBC</abbr>)
 to a variety of peripheral devices, including analog to digital and 
digital to analog converters, real time clocks, sensors, and actuators. 
 Because the SPI bus is implemented using separate clock, transmit and 
receive data lines, each communicating device can simultaneously send 
and receive data over the SPI link.
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h2 class="sectionedit2" id="using-the-spi-bus-for-fast-serial-data-exchange">Using the SPI bus for fast serial data exchange</h2><div class="level2">
<p>The <abbr title="Once Motorola, manufacturer of the 68HC11, MC68HC11F1, 9S12, HCS12, MCHCS12, 68HCS12, MC9S12DP512 and MC9S12A512 single chip microcontrollers">Freescale</abbr> <abbr title="Motorola/Freescale family of 16-bit single chip microcontrollers, e.g., MC9S12DP512 and MC9S12A512, aka HCS12 or MC9S12, newest versions of the 68HC11 and 68HC12 embeddable computers">9S12</abbr> (<abbr title="Motorola/Freescale family of 16-bit single chip microcontrollers, e.g., MC9S12DP512 and MC9S12A512, aka 9S12, MC9S12, newest versions of the 68HC11 and 68HC12 computers, for embedded systems">HCS12</abbr>) processor includes three synchronous SPI ports named <code>SPI0</code>, <code>SPI1</code>, and <code>SPI2</code>.  <code>SPI0</code> is available for general use, and is brought out to the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> expansion bus.  It is also used to interface to the real-time battery-backed clock/calendar on the PDQ Board. 
</p>
<p><code>SPI1</code> and <code>SPI2</code> are used for inter-processor 
communications on custom parallel-processing systems, and are brought 
out to a dedicated 10-pin SPI header.  If parallel processing is not 
required, these ports can be used to interface to other peripheral 
devices.
</p>
<p>A set of software drivers supports the SPI channels, making it easy 
for C language application programs to initialize the ports, change 
their baud rates and clock edge specifications, and exchange data with 
peripherals. 
</p>
<p>The SPI links on the HCS12 processor can transfer data over short 
distances much more rapidly than the RS232/485 or IIC serial links on 
the HCS12.   The HCS12 can run as an SPI bus master at data clock rates 
up to 10 <abbr title="Megahertz">MHz</abbr>, and the maximum data transfer rate for an SPI slave is 5 megabits/second.
</p>
<p>This section describes the SPI pins, how to connect them, and how to 
use the pre-coded driver functions to control these fast serial links 
for instrument control applications.
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h2 class="sectionedit3" id="spi-bus-pinssck-mosi-and-miso">SPI bus pins: SCK, MOSI, and MISO</h2><div class="level2">
<p>Hardware is interfaced to the <code>SPI0</code> (SPI channel 0) via three pins named <code>SCK</code>, <code>MOSI</code>, and <code>MISO</code> brought out to pins 7, 8, and 10 on the Wildcard port headers (see Appendix B).  The <code>SCK</code>
 (serial clock) pin is a configurable synchronous data clock output.  
This signal synchronizes the exchange of data between the PDQ Board and 
its peripherals. 
</p>
<p>Serial Peripheral Interface (SPI) ports <code>SPI1</code> and <code>SPI2</code> are brought out to a custom 10-pin header which provides the three signals <code>MOSI</code>, <code>MISO</code>, and <code>SCK</code> for both <code>SPI1</code> and <code>SPI2</code>, plus the <code>/SS</code>
 signal for both channels.  After each startup, one of these two SPI 
ports is configured as a bus master, and the other as a slave.  The <code>SPI #2</code> jumper determines this configuration: if the jumper is <strong>not</strong> installed, <code>SPI1</code> is the bus master and <code>SPI2</code> is the slave. If the jumper <strong>is</strong> installed, <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  This allows pin-to-pin connections between the SPI headers of a PDQ Board without the <code>SPI #2</code> jumper installed, and another PDQ Board that does have the <code>SPI #2</code>
 jumper installed; each board would be a master on one channel and a 
slave on the other.  The following table illustrates the SPI header 
pinout on the PDQ Board. 
</p><div class="table sectionedit4"><table class="inline"><tbody><tr class="row0"><th class="col0 centeralign" colspan="4">  H5: SPI Header  </th></tr><tr class="row1"><th class="col0 rightalign">  Signal </th><th class="col1 centeralign" colspan="2">  Pins  </th><th class="col3 leftalign"> Signal  </th></tr><tr class="row2"><td class="col0 rightalign">  /SS1 </td><td class="col1"> —1 </td><td class="col2 rightalign">  2— </td><td class="col3 leftalign"> /SS2  </td></tr><tr class="row3"><td class="col0 rightalign">  SCK1 </td><td class="col1"> —3 </td><td class="col2 rightalign">  4— </td><td class="col3 leftalign"> /SCK2  </td></tr><tr class="row4"><td class="col0 rightalign">  MOSI1 </td><td class="col1"> —5 </td><td class="col2 rightalign">  6— </td><td class="col3"> MOSI2 </td></tr><tr class="row5"><td class="col0 rightalign">  MISO1 </td><td class="col1"> —7 </td><td class="col2 rightalign">  8— </td><td class="col3 leftalign"> MISO2  </td></tr><tr class="row6"><td class="col0 rightalign">  DGND </td><td class="col1"> —9 </td><td class="col2 rightalign">  10— </td><td class="col3 leftalign"> /XIRQ  </td></tr></tbody></table></div>

<p>The byte-sized messages are transmitted and received via the <code>MOSI</code> (Master Out/Slave In) and <code>MISO</code> (Master In/Slave Out) pins.  The <code>/SS</code> (active-low slave select input) can be used to enable data transfers by slave devices when it is active low.  The <code>SPI0</code> <code>/SS</code>
 pin is not brought out to the Wildcard bus, and is instead used to 
control the chip select for the onboard battery-backed clock.  The HCS12
 is typically the SPI0 bus master on the Wildcard bus, and in this 
configuration the <code>/SS</code> pin is not needed.  The <code>/SS1</code> and <code>/SS2</code> pins of the <code>SPI1</code> and <code>SPI2</code>
 channels are brought out to the dedicated 10-pin SPI header on the PDQ 
Board.  Note that a common ground connection is necessary among the 
devices that communicate via the SPI.
</p>
<p>When the PDQ Board controls the SPI network, it is referred to as a <em>master</em>; otherwise, it is a <em>slave</em>.
  The device that initiates a data transfer is the master, and all other
 devices on the network are slaves.  Only one active master may control 
the network at a time, and this is typically the HCS12 on the <code>SPI0</code> bus, as the processor is typically controlling peripheral devices implemented on the Wildcard <abbr title="Digital and/or Analog Input and Output lines">I/O</abbr>
 boards.  Regardless of which device is the master or slave, both 
communicating devices can simultaneously send and receive data over the 
SPI bus.
</p>
<p>If you are using the PDQ Board as a master device, each external SPI device requires a separate chip select line.  The <abbr title="Modular digital, analog, and RS232, UART, USB serial communications input-output I-O boards, for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcards</abbr> that use the SPI link automatically generate the required chip select signal on each Wildcard. 
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h2 class="sectionedit5" id="connecting-to-the-spi-bus">Connecting to the SPI bus</h2><div class="level2">
<p>Configured as a master device, the PDQ Board transmits bytes via the “master out/slave in” pin, <code>MOSI</code>.  It receives bytes sent by a slave device via the “master in/slave out” pin, <code>MISO</code>.
  Transmissions are always initiated by the master device, and consist 
of an exchange of bytes.  As the master transmits a byte to an active 
slave (that is, a slave with its chip select input signal asserted), the
 master also receives a byte from the slave.  It may be that only the 
byte sent from the master to the slave is meaningful, or that only the 
byte sent from the slave to the master is meaningful.  Nevertheless, 
each device simultaneously transmits and receives one byte.  The only 
difference between the master and slave devices is that the master 
initiates the transmission and generates the clock output.
</p>
<p>Slave devices use the master in/slave out pin, <code>MISO</code>, for transmitting, and the master out/slave in pin, <code>MOSI</code>, for receiving data.  The following wiring diagram illustrates how the <code>MOSI</code>, and <code>MISO</code> pins of a master and a slave would be connected to exchange data:
</p><div class="block center" style="width:32em;"><div class="table sectionedit6"><table class="inline" style="width: 32em;">
<colgroup><col style="width: 15em"><col style="width: 2em"><col></colgroup><tbody><tr class="row0"><th class="col0 rightalign">   Master </th><th class="col1 leftalign">	</th><th class="col2 leftalign"> Slave  </th></tr><tr class="row1"><td class="col0 rightalign">    MOSI </td><td class="col1 centeralign">  <span style="font-size:124.999%;">→</span>  </td><td class="col2 leftalign"> MOSI  </td></tr><tr class="row2"><td class="col0 rightalign">    MISO </td><td class="col1 centeralign">  <span style="font-size:124.999%;">←</span>  </td><td class="col2 leftalign"> MISO  </td></tr><tr class="row3"><td class="col0 rightalign">     SCK </td><td class="col1 centeralign">  <span style="font-size:124.999%;">→</span>  </td><td class="col2 leftalign"> SCK   </td></tr><tr class="row4"><td class="col0 rightalign">     /SS </td><td class="col1 centeralign">  <span style="font-size:124.999%;">→</span>  </td><td class="col2"> /SS (chip select asserted) </td></tr><tr class="row5"><td class="col0 rightalign">     GND </td><td class="col1 centeralign">  <span style="font-size:124.999%;">↔</span>  </td><td class="col2 leftalign"> GND   </td></tr></tbody></table></div>
</div>
<p>The status of a device as master or slave determines how the various 
pins must be configured.  The arrows in the diagram point to pins 
configured as inputs, and originate from output pins.  Thus, the master 
has only one input, <code>MISO</code>, which is the slave’s only output.  Note that the master device outputs the clock synchronization signal <code>SCK</code> to the slave’s <code>SCK</code> input.  Also, in the diagram, the master’s <code>/SS</code>
 (slave select) is shown as an output, but this master output is not 
required as long as a chip select for the slave is implemented in some 
way.  As noted above, the <code>/SS</code> signal is not brought out for the <code>SPI0</code> link.  The <code>GND</code> line serves as a common voltage reference for the master and slave.
</p>
<p>There are a variety of ways the <code>MOSI</code>, <code>MISO</code>, <code>SCK</code> and <code>/SS</code>
 pins on the PDQ Board can be connected.  The one you choose depends on 
the specific device, or devices you will be connecting to.  In some 
circumstances a one-way data flow may suffice.  For example, a PDQ Board
 connected to a serial <abbr title="Analog to Digital Converter, A/D, ATD, often a hardware module on embedded microcontrollers">ADC</abbr> (analog to digital converter) on a Wildcard might have these connections:
</p><div class="block center" style="width:32em;"><div class="table sectionedit7"><table class="inline" style="width: 32em;">
<colgroup><col style="width: 15em"><col style="width: 2em"><col></colgroup><tbody><tr class="row0"><th class="col0 rightalign">      Master PDQ Board </th><th class="col1 leftalign">           </th><th class="col2 leftalign"> Slave Serial <abbr title="Analog to Digital (Converter), ADC, ATD, often a hardware module on embedded microcontrollers">A/D</abbr> Device   </th></tr><tr class="row1"><td class="col0 rightalign">                  MOSI </td><td class="col1 centeralign">  <span style="font-size:124.999%;">→</span>  </td><td class="col2 leftalign"> not connected      </td></tr><tr class="row2"><td class="col0 rightalign">                  MISO </td><td class="col1 centeralign">  <span style="font-size:124.999%;">←</span>  </td><td class="col2 leftalign"> Conversion Output  </td></tr><tr class="row3"><td class="col0 rightalign">                   SCK </td><td class="col1 centeralign">  <span style="font-size:124.999%;">→</span>  </td><td class="col2 leftalign"> CLK                </td></tr><tr class="row4"><td class="col0 rightalign">  memory-mapped output </td><td class="col1 centeralign">  <span style="font-size:124.999%;">↔</span>  </td><td class="col2 leftalign"> /CS                </td></tr><tr class="row5"><td class="col0 rightalign">                   GND </td><td class="col1 centeralign">  <span style="font-size:124.999%;">↔</span>  </td><td class="col2 leftalign"> GND                </td></tr></tbody></table></div>
</div>
<p>In this example, the PDQ Board selects the serial ADC by addressing a
 memory location on the Wildcard that contains the ADC; a logic chip on 
the Wildcard strobes the chip select to the active state when the 
specified address appears on the bus.  Even though the <code>MOSI</code> pin is not connected to anything, the master initiates a transmission by outputting a “dummy” byte on <code>SPI0</code>.  The <code>SCK</code> pin clocks the serial ADC’s <code>CLK</code> input which causes the ADC’s conversion result to be transferred to the master via the <code>MISO</code> line.
</p>
<p>The PDQ Board allows the details of the synchronous communications 
protocol to be customized for compatibility with a variety of 
peripherals.  The next section describes the software drivers that 
configure and control the SPI links.
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h2 class="sectionedit8" id="software-drivers-for-the-spi">Software drivers for the SPI</h2><div class="level2">
<p>The following table summarizes the software functions that make it easy to use the SPI channels on the PDQ Board.
</p><div class="table sectionedit9"><table class="inline"><tbody><tr class="row0"><th class="col0 centeralign" colspan="3">  Driver Routines for the SPI  </th></tr><tr class="row1"><td class="col0 leftalign"> <span class="glossary" id="_910935606" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_910935606" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>   </td><td class="col1 leftalign"> <span class="glossary" id="_220144339" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_220144339" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>                </td><td class="col2 leftalign"> <span class="glossary" id="_2029710112" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_2029710112" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>    </td></tr><tr class="row2"><td class="col0 leftalign"> <span class="glossary" id="_284604596" onclick="msc_positionPopup(this)">InitSPI()</span><span><!--<div id="pop_284604596" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitSPI( void)</code>
</p>
<p>Configures and enables the serial peripheral interface channel <code>SPI0</code> so that it can transfer data on the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> bus stacks and to/from the on-board battery-backed real-time clock.  Initializes the 68HCS12 as the SPI <em>master</em> with 2 MHz data transfer, with clock idling low, valid data present/sampled on the falling trailing edge of the SPI clock, and data transferred on the rising/leading clock edge.  Also initializes the resource variable <code>SPI_RESOURCE</code> to zero.  This routine is called upon each power-up or restart.
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>     </td><td class="col1 leftalign"> <span class="glossary" id="_1779763867" onclick="msc_positionPopup(this)">SPI_RISING_LEADING_EDGE</span><span><!--<div id="pop_1779763867" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_rising_leading_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RISING_LEADING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_RISING_LEADING_EDGE</code> specifies a clock that idles in the logic low state, with data valid and sampled on the rising leading edge transition of the clock.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 0 and <code>CPHA</code> = 0 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.     
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.RISING.LEADING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>     </td><td class="col2 leftalign"> <span class="glossary" id="_1542444865" onclick="msc_positionPopup(this)">SPIFrequencies()</span><span><!--<div id="pop_1542444865" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spifrequencies' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIFrequencies( void )</code>
</p>
<p>This function prints a formatted table of all 64 possible contents of the <code>SPIBR</code> register (serial peripheral interface baud rate) register in both hex and decimal, followed by the corresponding decimal SPI bus frequency.  Units are kHz, and the result is rounded to the nearest kHz.  To use this function, type:
</p><pre class="code">
SPI.FREQUENCIES </pre>
<p>(the Forth version of the function name) interactively at the terminal and examine the resulting data table to select the <code>SPIBR</code> register contents that yield the desired SPI bus clock frequency, and pass the selected value to <code>SPIConfig()</code> (see its glossary entry).  If you prefer to work strictly in C, you can invoke the <code>SPIFrequencies()</code> function from a compiled C program to create the printout.  After a power-up or restart, the default <code>SPI0</code> baud rate register contents equals  0x40, yielding a 2000 kHz (2MHz) baud rate which is the default for the SPI link on the Wildcard bus; the <code>SPI1</code> and <code>SPI2</code> buses run at 5MHz after a restart.  When executed, the first few lines of the resulting printout look like this:
</p><pre class="code">
Pass the selected SPIBR constant to SPIConfig (or to SPI.CONFIG in Forth).
0xSPIBR  SPIBR  BAUD.KHZ (decimal)
0x0         0    10000
0x1         1    5000
0x2         2    2500
0x3         3    1250</pre>
<p>Type: kernel function
<br/>Forth name: <code>SPI.FREQUENCIES</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>  </td></tr><tr class="row3"><td class="col0 leftalign"> <span class="glossary" id="_1305567664" onclick="msc_positionPopup(this)">SPI_FALLING_LEADING_EDGE</span><span><!--<div id="pop_1305567664" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_falling_leading_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_FALLING_LEADING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_FALLING_LEADING_EDGE</code> specifies a clock that idles in the logic high state, with data valid and sampled on the falling leading edge transition of the clock.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 1 and <code>CPHA</code> = 0 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.FALLING.LEADING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>   </td><td class="col1 leftalign"> <span class="glossary" id="_89872253" onclick="msc_positionPopup(this)">SPI_RISING_TRAILING_EDGE</span><span><!--<div id="pop_89872253" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_rising_trailing_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RISING_TRAILING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_RISING_TRAILING_EDGE</code> specifies a clock that idles in the logic high state, with data valid and sampled on the rising trailing edge transition of the clock.  Data is transferred on the falling leading clock edge so that it is stable and ready to be sampled at the rising trailing edge. 
</p>
<p>Implementation detail: When passed to <code>SPIConfig()</code>, results in <code>CPOL</code> = 1 and <code>CPHA</code> = 1 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.     
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.RISING.TRAILING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>  </td><td class="col2 leftalign"> <span class="glossary" id="_280415407" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_280415407" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>  </td></tr><tr class="row4"><td class="col0 leftalign"> <span class="glossary" id="_1719080071" onclick="msc_positionPopup(this)">SPI_FALLING_TRAILING_EDGE</span><span><!--<div id="pop_1719080071" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_falling_trailing_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_FALLING_TRAILING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_FALLING_TRAILING_EDGE</code> specifies a clock that idles in the logic low state, with data valid and sampled on the falling trailing edge transition of the clock.  Data is transferred on the rising leading clock edge so that it is stable and ready to be sampled at the falling trailing edge.  This is the default clock edge specifier established after a power-up or restart, and it is the proper configuration for communications with the onboard battery-backed Real-Time clock that is performed by the operating system’s <code><a href="#setwatch" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SetWatch</a>()</code> and <code><a href="#readwatch" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">ReadWatch</a>()</code> functions.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 0 and <code>CPHA</code> = 1 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.FALLING.TRAILING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>  </td><td class="col1 leftalign"> <span class="glossary" id="_1092664051" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1092664051" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>            </td><td class="col2 leftalign"> <span class="glossary" id="_1074635000" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_1074635000" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>   </td></tr></tbody></table></div>

<p>The <span class="glossary" id="_562994403" onclick="msc_positionPopup(this)">InitSPI()</span><span><!--<div id="pop_562994403" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitSPI( void)</code>
</p>
<p>Configures and enables the serial peripheral interface channel <code>SPI0</code> so that it can transfer data on the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> bus stacks and to/from the on-board battery-backed real-time clock.  Initializes the 68HCS12 as the SPI <em>master</em> with 2 MHz data transfer, with clock idling low, valid data present/sampled on the falling trailing edge of the SPI clock, and data transferred on the rising/leading clock edge.  Also initializes the resource variable <code>SPI_RESOURCE</code> to zero.  This routine is called upon each power-up or restart.
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function is automatically executed upon each power-up or restart to configure and enable <code>SPI0</code>
 only (serial peripheral interface channel 0), so that it can transfer 
data on the Wildcard ports and to/from the on-board battery-backed 
real-time clock.  <span class="glossary" id="_273151084" onclick="msc_positionPopup(this)">InitSPI()</span><span><!--<div id="pop_273151084" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitSPI( void)</code>
</p>
<p>Configures and enables the serial peripheral interface channel <code>SPI0</code> so that it can transfer data on the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> bus stacks and to/from the on-board battery-backed real-time clock.  Initializes the 68HCS12 as the SPI <em>master</em> with 2 MHz data transfer, with clock idling low, valid data present/sampled on the falling trailing edge of the SPI clock, and data transferred on the rising/leading clock edge.  Also initializes the resource variable <code>SPI_RESOURCE</code> to zero.  This routine is called upon each power-up or restart.
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> generally does not need to be 
explicitly called from your software application.  This function 
initializes the HCS12 as the SPI master with 2 MHz data transfer, with 
clock idling low, and valid data present/sampled on the falling trailing
 edge of the SPI clock.  Data is transferred on the rising/leading clock
 edge, which is one-half clock cycle before it is sampled.  This is a 
generally useful configuration, and it can be easily changed using the <span class="glossary" id="_160054079" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_160054079" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function, along with <span class="glossary" id="_685725255" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_685725255" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> and <span class="glossary" id="_1813125064" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_1813125064" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> as described below.  <span class="glossary" id="_1914014618" onclick="msc_positionPopup(this)">InitSPI()</span><span><!--<div id="pop_1914014618" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitSPI( void)</code>
</p>
<p>Configures and enables the serial peripheral interface channel <code>SPI0</code> so that it can transfer data on the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> bus stacks and to/from the on-board battery-backed real-time clock.  Initializes the 68HCS12 as the SPI <em>master</em> with 2 MHz data transfer, with clock idling low, valid data present/sampled on the falling trailing edge of the SPI clock, and data transferred on the rising/leading clock edge.  Also initializes the resource variable <code>SPI_RESOURCE</code> to zero.  This routine is called upon each power-up or restart.
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> also initializes the resource variable <span class="glossary" id="_1804120960" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_1804120960" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span> to zero.
</p>
<p>The <span class="glossary" id="_1396022451" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_1396022451" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function initializes SPI channels <code>SPI1</code> and <code>SPI2</code>, and is <strong>not</strong> automatically called on reset and startup.  In order to use <code>SPI1</code> or <code>SPI2</code>, your code <strong>must</strong> explicitly call <span class="glossary" id="_2013561572" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_2013561572" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> before calling <span class="glossary" id="_492952829" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_492952829" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> for these channels.  <code>SPI1</code> and <code>SPI2</code>
 are used for inter-processor communications on custom 
parallel-processing systems.  If parallel processing is not required, 
these channels may be used to communicate with other peripherals, and 
their baud rate and clock edge specifiers may be changed using the <span class="glossary" id="_606429618" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_606429618" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master SPI and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master. After <span class="glossary" id="_185387131" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_185387131" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> executes, the <code>SPI1</code> and <code>SPI2</code>
 clocks idle low, data is sampled/valid on the falling/trailing clock 
edge, and data is transferred on the rising leading clock edge.   The 
default baud rate is set to 5 MHz.
</p>
<p>To select a configuration for a given SPI peripheral, consult the 
peripheral’s data sheet to discover the proper data-valid clock edge and
 baud rate, and use <span class="glossary" id="_1181877984" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1181877984" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> to configure the specified SPI channel.  For instance, here is the passage in the data sheet for the <a href="http://www.mosaic-industries.com/embedded-systems/instrumentation/2x16-4x20-lcd-serial-displays-backlight/microcontroller" class="wikilink1" title="instrumentation:2x16-4x20-lcd-serial-displays-backlight:microcontroller">2x16 character serial display</a> provided by Mosaic describing the display's SPI interface:
</p><pre class="code">SPI mode has a normally high level idle clock. When Slave Select is LOW,
data is sampled on the rising edge of the Clock.
The SPI interface is capable of receiving data at up to 100KHz clock rate.</pre>
<p>In order to configure <code>SPI1</code> to communicate with this device, <span class="glossary" id="_1187483501" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1187483501" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> would be called as follows:
</p><pre class="c code c"><span class="co1">// Selected from the output of SPI.FREQUENCIES on the PDQ Board.</span>
<span class="co2">#define PDQ_SPI_BAUD_89KHZ 0x64</span>
&nbsp;
<span class="kw4">void</span> display_initialize<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    InitIPSPI<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    SPIConfig<span class="br0">(</span> SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> PDQ_SPI_BAUD_89KHZ<span class="sy0">,</span> <span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
<p><span class="glossary" id="_837800777" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_837800777" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> configures the baud rate and 
data-valid clock edge of the specified SPI channel (0, 1 or 2).  All 
other configuration parameters (master/slave, mode fault enable, SPI 
interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <span class="glossary" id="_900790745" onclick="msc_positionPopup(this)">InitSPI()</span><span><!--<div id="pop_900790745" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitSPI( void)</code>
</p>
<p>Configures and enables the serial peripheral interface channel <code>SPI0</code> so that it can transfer data on the <abbr title="Modular digital, analog, and RS232, UART, USB serial communications, input-output I-O boards for industrial control, process control, data acquisition from sensors, measurement and control, robotics, motor control, ATD DTA, GPS, SCADA, WiFi web server &amp; Ethernet">Wildcard</abbr> bus stacks and to/from the on-board battery-backed real-time clock.  Initializes the 68HCS12 as the SPI <em>master</em> with 2 MHz data transfer, with clock idling low, valid data present/sampled on the falling trailing edge of the SPI clock, and data transferred on the rising/leading clock edge.  Also initializes the resource variable <code>SPI_RESOURCE</code> to zero.  This routine is called upon each power-up or restart.
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> for the <code>SPI0</code> channel, or <span class="glossary" id="_974192283" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_974192283" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> for the <code>SPI1</code> and <code>SPI2</code> channels.  The <code>clock_edge_specifier</code> passed to <span class="glossary" id="_405117158" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_405117158" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> is one of the 4 named constants <span class="glossary" id="_1902998944" onclick="msc_positionPopup(this)">SPI_FALLING_TRAILING_EDGE</span><span><!--<div id="pop_1902998944" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_falling_trailing_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_FALLING_TRAILING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_FALLING_TRAILING_EDGE</code> specifies a clock that idles in the logic low state, with data valid and sampled on the falling trailing edge transition of the clock.  Data is transferred on the rising leading clock edge so that it is stable and ready to be sampled at the falling trailing edge.  This is the default clock edge specifier established after a power-up or restart, and it is the proper configuration for communications with the onboard battery-backed Real-Time clock that is performed by the operating system’s <code><a href="#setwatch" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SetWatch</a>()</code> and <code><a href="#readwatch" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">ReadWatch</a>()</code> functions.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 0 and <code>CPHA</code> = 1 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.FALLING.TRAILING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> (the default after a restart), <span class="glossary" id="_399753507" onclick="msc_positionPopup(this)">SPI_RISING_LEADING_EDGE</span><span><!--<div id="pop_399753507" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_rising_leading_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RISING_LEADING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_RISING_LEADING_EDGE</code> specifies a clock that idles in the logic low state, with data valid and sampled on the rising leading edge transition of the clock.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 0 and <code>CPHA</code> = 0 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.     
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.RISING.LEADING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>, <span class="glossary" id="_1530229634" onclick="msc_positionPopup(this)">SPI_FALLING_LEADING_EDGE</span><span><!--<div id="pop_1530229634" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_falling_leading_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_FALLING_LEADING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_FALLING_LEADING_EDGE</code> specifies a clock that idles in the logic high state, with data valid and sampled on the falling leading edge transition of the clock.
</p>
<p>Implementation detail: When passed to <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, results in <code>CPOL</code> = 1 and <code>CPHA</code> = 0 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.FALLING.LEADING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>, or <span class="glossary" id="_2147325886" onclick="msc_positionPopup(this)">SPI_RISING_TRAILING_EDGE</span><span><!--<div id="pop_2147325886" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_rising_trailing_edge' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RISING_TRAILING_EDGE</code>
</p>
<p>A constant that returns a clock edge specifier to be passed to the <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> function to specify the SPI (serial peripheral interface) data-valid clock edge.  <code>SPI_RISING_TRAILING_EDGE</code> specifies a clock that idles in the logic high state, with data valid and sampled on the rising trailing edge transition of the clock.  Data is transferred on the falling leading clock edge so that it is stable and ready to be sampled at the rising trailing edge. 
</p>
<p>Implementation detail: When passed to <code>SPIConfig()</code>, results in <code>CPOL</code> = 1 and <code>CPHA</code> = 1 in the <code>SPI0CR1</code> register of the <code>SPI0</code> channel.     
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.RISING.TRAILING.EDGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>.  The first two of these specify a 
clock that idles in the low state, and the latter two specify a clock 
that idles high.  Each named constant describes the clock edge at which 
the data is sampled and valid; the data is typically transferred on the 
SPI bus one half cycle before the specified edge.
</p>
<p>The baud rate parameter <code>spibr_contents</code> passed to <span class="glossary" id="_1315083145" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1315083145" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> is the contents of the register that 
sets the desired baud rate on the specified SPI channel.  The 
correspondence between the desired baud rate and the baud rate register 
contents is determined by a multivariate equation, so it is easiest to 
choose the correct value from a table of the available SPI frequencies. 
 The C function <span class="glossary" id="_1620138088" onclick="msc_positionPopup(this)">SPIFrequencies()</span><span><!--<div id="pop_1620138088" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spifrequencies' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIFrequencies( void )</code>
</p>
<p>This function prints a formatted table of all 64 possible contents of the <code>SPIBR</code> register (serial peripheral interface baud rate) register in both hex and decimal, followed by the corresponding decimal SPI bus frequency.  Units are kHz, and the result is rounded to the nearest kHz.  To use this function, type:
</p><pre class="code">
SPI.FREQUENCIES </pre>
<p>(the Forth version of the function name) interactively at the terminal and examine the resulting data table to select the <code>SPIBR</code> register contents that yield the desired SPI bus clock frequency, and pass the selected value to <code>SPIConfig()</code> (see its glossary entry).  If you prefer to work strictly in C, you can invoke the <code>SPIFrequencies()</code> function from a compiled C program to create the printout.  After a power-up or restart, the default <code>SPI0</code> baud rate register contents equals  0x40, yielding a 2000 kHz (2MHz) baud rate which is the default for the SPI link on the Wildcard bus; the <code>SPI1</code> and <code>SPI2</code> buses run at 5MHz after a restart.  When executed, the first few lines of the resulting printout look like this:
</p><pre class="code">
Pass the selected SPIBR constant to SPIConfig (or to SPI.CONFIG in Forth).
0xSPIBR  SPIBR  BAUD.KHZ (decimal)
0x0         0    10000
0x1         1    5000
0x2         2    2500
0x3         3    1250</pre>
<p>Type: kernel function
<br/>Forth name: <code>SPI.FREQUENCIES</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> calculates and prints this table to the serial port.  If you prefer to work strictly in C, you can invoke the <span class="glossary" id="_1467064128" onclick="msc_positionPopup(this)">SPIFrequencies()</span><span><!--<div id="pop_1467064128" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spifrequencies' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIFrequencies( void )</code>
</p>
<p>This function prints a formatted table of all 64 possible contents of the <code>SPIBR</code> register (serial peripheral interface baud rate) register in both hex and decimal, followed by the corresponding decimal SPI bus frequency.  Units are kHz, and the result is rounded to the nearest kHz.  To use this function, type:
</p><pre class="code">
SPI.FREQUENCIES </pre>
<p>(the Forth version of the function name) interactively at the terminal and examine the resulting data table to select the <code>SPIBR</code> register contents that yield the desired SPI bus clock frequency, and pass the selected value to <code>SPIConfig()</code> (see its glossary entry).  If you prefer to work strictly in C, you can invoke the <code>SPIFrequencies()</code> function from a compiled C program to create the printout.  After a power-up or restart, the default <code>SPI0</code> baud rate register contents equals  0x40, yielding a 2000 kHz (2MHz) baud rate which is the default for the SPI link on the Wildcard bus; the <code>SPI1</code> and <code>SPI2</code> buses run at 5MHz after a restart.  When executed, the first few lines of the resulting printout look like this:
</p><pre class="code">
Pass the selected SPIBR constant to SPIConfig (or to SPI.CONFIG in Forth).
0xSPIBR  SPIBR  BAUD.KHZ (decimal)
0x0         0    10000
0x1         1    5000
0x2         2    2500
0x3         3    1250</pre>
<p>Type: kernel function
<br/>Forth name: <code>SPI.FREQUENCIES</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function from a compiled C program to
 create the printout.  The easiest way to view the table, however, is to
 use the interactive <abbr title="A real time operating system (RTOS), IDE, interpreter, compiler and programming language available in firmware on Mosaic's microcontrollers and single board computers, well suited to rapid application development">Forth</abbr> version of the function by typing at the terminal:
</p><pre class="code">SPI.FREQUENCIES ↓</pre>
<p>This function prints a formatted table of all 64 possible contents of
 the baud register.   The first few lines of the resulting printout look
 like this:
</p><pre class="code">Pass the selected SPIBR constant to SPIConfig (or to SPI.CONFIG in Forth).
0xSPIBR  SPIBR  BAUD.KHZ  (decimal)
0x0           0           10000
0x1           1            5000
0x2           2            2500
0x3           3            1250
. . .</pre>
<p>Each line of the table lists the baud register contents in both hex 
and decimal, followed by the corresponding decimal SPI bus frequency in 
kHz, with the result rounded to the nearest kHz.  After executing this 
function, examine the resulting data table to select the <code>spibr_contents</code> parameter that yields the desired SPI bus clock frequency, and pass the selected value to <span class="glossary" id="_1846829813" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1846829813" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>.  
To exchange data with a peripheral on the SPI bus, use the <span class="glossary" id="_1161302791" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1161302791" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function.  Simply place the information to be transmitted into a <abbr title="Random Access Memory, volatile memory used for variable storage">RAM</abbr> buffer and invoke <span class="glossary" id="_1361670931" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1361670931" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>; any returning bytes from the slave can be placed into the buffer.
</p>
<p>The underlying function <span class="glossary" id="_1740927805" onclick="msc_positionPopup(this)">SPIExchange()</span><span><!--<div id="pop_1740927805" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange1' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIExchange( void* base_addr, uint base_page, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>A subsidiary Forth function called by the recommended macro <code>SPIEXCHANGE</code>().  This function may be used directly if data is to be exchanged on an SPI channel to or from paged memory by specifying the memory page in the parameter <code>base_page</code>.  If the <code>readback</code> flag is nonzero, <code>base_page</code> must be RAM, and the buffer specified by <code>base_addr</code> will be overwritten with incoming data on the SPI channel&#039;s MISO pin. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> is called by the macro <span class="glossary" id="_1110568241" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1110568241" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>, and allows specifying a memory page.  <span class="glossary" id="_740931038" onclick="msc_positionPopup(this)">SPIExchange()</span><span><!--<div id="pop_740931038" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange1' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIExchange( void* base_addr, uint base_page, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>A subsidiary Forth function called by the recommended macro <code>SPIEXCHANGE</code>().  This function may be used directly if data is to be exchanged on an SPI channel to or from paged memory by specifying the memory page in the parameter <code>base_page</code>.  If the <code>readback</code> flag is nonzero, <code>base_page</code> must be RAM, and the buffer specified by <code>base_addr</code> will be overwritten with incoming data on the SPI channel&#039;s MISO pin. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> may be called directly if data from 
paged memory (non-common memory) is be exchanged on an SPI channel.  All
 C variables, arrays and strings are located in common memory unless 
specific qualifiers such as <code>_rom</code> are added to their declarations to place them elsewhere, so generally only the macro <span class="glossary" id="_1022209342" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1022209342" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> will be necessary.
</p>
<p>For example, here is how a message would be sent to the <a href="http://www.mosaic-industries.com/embedded-systems/instrumentation/2x16-4x20-lcd-serial-displays-backlight/microcontroller" class="wikilink1" title="instrumentation:2x16-4x20-lcd-serial-displays-backlight:microcontroller">serial character display</a> mentioned above, on <code>SPI1</code>:
</p><pre class="c code c"><span class="kw4">char</span> greeting<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">"Hi!"</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> display_show_greeting<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Strings and arrays may both be directly used as pointers to their</span>
    <span class="co1">// contents, in this case providing the 'base_addr' parameter.</span>
    <span class="co1">// 'strlen()' counts number of bytes before a C string null</span>
    <span class="co1">// terminator. 'readback' is zero since no data is being received.</span>
    <span class="co1">// '1' indicates SPI1.</span>
    SPIEXCHANGE<span class="br0">(</span> greeting<span class="sy0">,</span> strlen<span class="br0">(</span>greeting<span class="br0">)</span><span class="sy0">,</span> FALSE<span class="sy0">,</span> <span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre>
<p><span class="glossary" id="_1722765211" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1722765211" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> writes to the specified <code>spi_channel</code> (set to <code>2</code> above) the contents of the buffer specified by <code>base_addr</code> in common memory (<code>greeting</code> is a pointer to the string "Hi!", or memory address at which that string is located), exchanging <code>numbytes</code> number of bytes (0 ⇐ numbytes &lt; 32,768, set equal to <code>strlen(greeting)</code> above).  The buffer must not cross a page boundary.  The <code>readback</code> flag is set to <code>FALSE</code> (zero) above, but if it were <code>TRUE</code>
 (nonzero) then a simultaneous readback from the specified remote SPI is
 performed, and the incoming bytes are written into the buffer 
(replacing the transmitted bytes).  See the glossary entry for <span class="glossary" id="_265367764" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_265367764" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> for more information.  Here is an example of reading 8 bytes from <code>SPI1</code> by setting the <code>readback</code> flag to <code>TRUE</code>:
</p><pre class="c code c"><span class="kw4">char</span> spi_buffer<span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">void</span> spidevice_getdata<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Read from the device attached to SPI1 and currently driving the MISO line.</span>
    <span class="co1">// 'sizeof()' only works properly on an actual array or struct. If 'spi_buffer'</span>
    <span class="co1">// were declared as a pointer and set equal to a specific memory location,</span>
    <span class="co1">// it would be necessary to specify its size in bytes explicitly.</span>
    SPIEXCHANGE<span class="br0">(</span> spi_buffer<span class="sy0">,</span> <span class="kw4">sizeof</span><span class="br0">(</span>spi_buffer<span class="br0">)</span><span class="sy0">,</span> TRUE<span class="sy0">,</span> <span class="nu0">1</span> <span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Note that regardless of whether simultaneous transmission of data is desired,</span>
    <span class="co1">// the prior contents of 'spi_buffer' will be sent. i.e., the prior contents</span>
    <span class="co1">// of 'spi_buffer' determine the state of the MOSI line during the execution of</span>
    <span class="co1">// SPIEXCHANGE().</span>
<span class="br0">}</span></pre>
<p>This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h3 class="sectionedit10" id="managing-multiple-devices-on-spi-channel-0">Managing multiple devices on SPI channel 0</h3><div class="level3">
<p>If you are commanding multiple peripheral devices through a single SPI port, you must control access to the SPI port as a <em>resource</em>.  The functions described so far do not <span class="glossary" id="_548152542" onclick="msc_positionPopup(this)">GET</span><span><!--<div id="pop_548152542" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>GET ( xresource && )</code>
</p>
<p>Used in a multitasking system to gain access to a shared resource.   PAUSEs until the resource variable whose address is xresource is available, and then GETs the resource by storing the task id (i.e., the <code>STATUS</code> xaddr) of the requesting task into the xresource.  <code>0\0</code> in xresource indicates that the resource is available, and a non-zero value that is not equal to the requesting task&#039;s id indicates that another task controls the resource.   To ensure that the state of the resource is correctly determined, <code>GET</code> disables interrupts for 0.25 to 1microsecond.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-a-d">?GET</a>, <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RELEASE</a>, and <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RESOURCE.VARIABLE:</a>
</p>
<p>Attributes: M
</p></span></span></div>--></span> or <span class="glossary" id="_1072093214" onclick="msc_positionPopup(this)">RELEASE</span><span><!--<div id="pop_1072093214" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RELEASE ( xresource && )</code>
</p>
<p>If the current task owns the resource variable referenced by xresource (i.e., if xresource contains the current task&#039;s xtask.id), releases the resource by storing <code>0\0</code> in xresource.   Otherwise, does nothing; this prevents a task from RELEASEing a resource controlled by another task.   Interrupts are not disabled and <code>PAUSE</code> is not executed.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-e-o">GET</a> and <a href="#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z &crarr;">RESOURCE.VARIABLE:</a>
</p></span></span></div>--></span> the <span class="glossary" id="_1528711156" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_1528711156" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>, nor do they save and restore the prior configuration of the SPI link.  For the <code>SPI0</code> channel, these important tasks are performed by the <span class="glossary" id="_2124657156" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_2124657156" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> and <span class="glossary" id="_112600958" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_112600958" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> functions. These two functions enable “polite” reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevent contention on the <code>SPI0</code> bus because they correctly <span class="glossary" id="_678300437" onclick="msc_positionPopup(this)">GET</span><span><!--<div id="pop_678300437" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>GET ( xresource && )</code>
</p>
<p>Used in a multitasking system to gain access to a shared resource.   PAUSEs until the resource variable whose address is xresource is available, and then GETs the resource by storing the task id (i.e., the <code>STATUS</code> xaddr) of the requesting task into the xresource.  <code>0\0</code> in xresource indicates that the resource is available, and a non-zero value that is not equal to the requesting task&#039;s id indicates that another task controls the resource.   To ensure that the state of the resource is correctly determined, <code>GET</code> disables interrupts for 0.25 to 1microsecond.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-a-d">?GET</a>, <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RELEASE</a>, and <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RESOURCE.VARIABLE:</a>
</p>
<p>Attributes: M
</p></span></span></div>--></span> and <span class="glossary" id="_611873834" onclick="msc_positionPopup(this)">RELEASE</span><span><!--<div id="pop_611873834" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RELEASE ( xresource && )</code>
</p>
<p>If the current task owns the resource variable referenced by xresource (i.e., if xresource contains the current task&#039;s xtask.id), releases the resource by storing <code>0\0</code> in xresource.   Otherwise, does nothing; this prevents a task from RELEASEing a resource controlled by another task.   Interrupts are not disabled and <code>PAUSE</code> is not executed.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-e-o">GET</a> and <a href="#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z &crarr;">RESOURCE.VARIABLE:</a>
</p></span></span></div>--></span> the <span class="glossary" id="_1716576235" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_1716576235" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>.  Proper use of these functions 
allows multiple devices (including the onboard battery-backed real-time 
clock and various Wildcards) to share the <code>SPI0</code> channel.
</p>
<p>As discussed in the chapter titled “Real Time Programming”, a 
resource variable can be assigned to a shared resource to mediate access
 to the resource from various software tasks.  The pre-defined resource 
variable <span class="glossary" id="_1809264195" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_1809264195" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span> controls access to the <code>SPI0</code> channel.  Software drivers for the onboard battery-backed real-time clock and for the Wildcards that use the <code>SPI0</code> channel <span class="glossary" id="_1075969522" onclick="msc_positionPopup(this)">GET</span><span><!--<div id="pop_1075969522" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>GET ( xresource && )</code>
</p>
<p>Used in a multitasking system to gain access to a shared resource.   PAUSEs until the resource variable whose address is xresource is available, and then GETs the resource by storing the task id (i.e., the <code>STATUS</code> xaddr) of the requesting task into the xresource.  <code>0\0</code> in xresource indicates that the resource is available, and a non-zero value that is not equal to the requesting task&#039;s id indicates that another task controls the resource.   To ensure that the state of the resource is correctly determined, <code>GET</code> disables interrupts for 0.25 to 1microsecond.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-a-d">?GET</a>, <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RELEASE</a>, and <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RESOURCE.VARIABLE:</a>
</p>
<p>Attributes: M
</p></span></span></div>--></span> the <span class="glossary" id="_2026759594" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_2026759594" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>, then configure and use the <code>SPI0</code> channel, then <span class="glossary" id="_1000865291" onclick="msc_positionPopup(this)">RELEASE</span><span><!--<div id="pop_1000865291" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RELEASE ( xresource && )</code>
</p>
<p>If the current task owns the resource variable referenced by xresource (i.e., if xresource contains the current task&#039;s xtask.id), releases the resource by storing <code>0\0</code> in xresource.   Otherwise, does nothing; this prevents a task from RELEASEing a resource controlled by another task.   Interrupts are not disabled and <code>PAUSE</code> is not executed.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-e-o">GET</a> and <a href="#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z &crarr;">RESOURCE.VARIABLE:</a>
</p></span></span></div>--></span> the <span class="glossary" id="_1751401044" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_1751401044" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>.  The <span class="glossary" id="_425175975" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_425175975" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> and <span class="glossary" id="_402902716" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_402902716" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> functions simplify the task of managing access to the <code>SPI0</code> channel.
</p>
<p><span class="glossary" id="_993385242" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_993385242" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> <span class="glossary" id="_852644159" onclick="msc_positionPopup(this)">GET</span><span><!--<div id="pop_852644159" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>GET ( xresource && )</code>
</p>
<p>Used in a multitasking system to gain access to a shared resource.   PAUSEs until the resource variable whose address is xresource is available, and then GETs the resource by storing the task id (i.e., the <code>STATUS</code> xaddr) of the requesting task into the xresource.  <code>0\0</code> in xresource indicates that the resource is available, and a non-zero value that is not equal to the requesting task&#039;s id indicates that another task controls the resource.   To ensure that the state of the resource is correctly determined, <code>GET</code> disables interrupts for 0.25 to 1microsecond.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-a-d">?GET</a>, <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RELEASE</a>, and <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RESOURCE.VARIABLE:</a>
</p>
<p>Attributes: M
</p></span></span></div>--></span>s the <span class="glossary" id="_192905322" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_192905322" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span>, then fetches and returns as a 32-bit quantity the contents of the four 1-byte configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <span class="glossary" id="_1349521727" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1349521727" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> to configure the SPI link and <span class="glossary" id="_1020162842" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_1020162842" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> to communicate with the specified 
peripheral, the 32-bit output parameter should be passed by the 
application program as the input to <span class="glossary" id="_38157896" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_38157896" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>.   <span class="glossary" id="_1866166318" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_1866166318" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> writes to the four 1-byte configuration registers to restore the prior <code>SPI0</code> configuration, and <span class="glossary" id="_980805233" onclick="msc_positionPopup(this)">RELEASE</span><span><!--<div id="pop_980805233" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RELEASE ( xresource && )</code>
</p>
<p>If the current task owns the resource variable referenced by xresource (i.e., if xresource contains the current task&#039;s xtask.id), releases the resource by storing <code>0\0</code> in xresource.   Otherwise, does nothing; this prevents a task from RELEASEing a resource controlled by another task.   Interrupts are not disabled and <code>PAUSE</code> is not executed.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-e-o">GET</a> and <a href="#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z &crarr;">RESOURCE.VARIABLE:</a>
</p></span></span></div>--></span>s the <span class="glossary" id="_210303068" onclick="msc_positionPopup(this)">SPI_RESOURCE</span><span><!--<div id="pop_210303068" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spi_resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>SPI_RESOURCE</code>
</p>
<p>A <a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a> variable associated with the serial peripheral interface channel 0 (<code>SPI0</code>) which is used for data transfer to and from the Wildcard bus and the battery-backed real-time clock.  Should be accessed only by the functions <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code>, <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  Initialized to zero at each reset or restart.  <code>SPI_RESOURCE</code> is automatically acquired by the battery-backed real-time clock device driver routines.
</p>
<p>Generally user applications will not acquire <code>SPI_RESOURCE</code> directly, but rather call <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.
</p>
<p>See also: <code><a href="#resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RESOURCE</a></code>, <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>
</p>
<p>Type: macro constant
<br/>Related Forth function: <code>SPI.RESOURCE</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span> to indicate that the <code>SPI0</code> channel is available to other tasks.  
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h3 class="sectionedit11" id="managing-multiple-devices-on-spi-channels-1-and-2">Managing multiple devices on SPI channels 1 and 2</h3><div class="level3">
<p>The functions that initialize, configure, and exchange data on the <code>SPI1</code> and <code>SPI2</code> channels are <span class="glossary" id="_2065268164" onclick="msc_positionPopup(this)">InitIPSPI()</span><span><!--<div id="pop_2065268164" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void InitIPSPI( void)</code>
</p>
<p>Initializes <abbr title="Serial Peripheral Interface, a fast bidirectional synchronous serial interface">SPI</abbr> channels <code>SPI1</code> and <code>SPI2</code>.  These SPI channels are used for inter-processor communications on custom parallel-processing systems.  If parallel processing is not required, the <code>SPI1</code> and <code>SPI2</code> channels may be used to communicate with other peripherals.  The <code>SPI #2</code> jumper on the PDQ Board determines which port this routine designates as the master and which as the slave.  If the <code>SPI #2</code> jumper cap is <strong>not</strong> installed, then <code>SPI1</code> is the master and <code>SPI2</code> is the slave.  If the <code>SPI #2</code> jumper <strong>is</strong> installed, then <code>SPI1</code> is the slave and <code>SPI2</code> is the master.  The <code>SPI1</code> and <code>SPI2</code> clocks idle low, data is sampled/valid on the falling/trailing clock edge, and data is transferred on the rising leading clock edge.  The default baud rate is set to 5 <abbr title="Megahertz">MHz</abbr>.  This routine is <strong>not</strong> called upon power-up or restart, and must be explicitly called by application code before calling <code>SPIConfig</code>().
</p>
<p>Type: kernel function
<br/>Forth name: <code>INIT.<abbr title="Inernet Protocol //or// Internet Protocol Address //or// Intellectual Property">IP</abbr>.SPI</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>, <span class="glossary" id="_2054580329" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_2054580329" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span>, and <span class="glossary" id="_88649798" onclick="msc_positionPopup(this)">SPIEXCHANGE()</span><span><!--<div id="pop_88649798" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiexchange' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIEXCHANGE( void* base_addr, uint numbytes, uint readback, uint spi_channel)</code>
</p>
<p>Writes to the specified <code>spi_channel</code> (= 0, 1 or 2) the contents of the buffer specified by <code>base_addr</code>, <code>numbytes</code> number of bytes (0 ≤ numbytes &lt; 32,768).  The buffer must be in common memory (all C variables, arrays and strings are common memory).  If the <code>readback</code> flag is nonzero, then a simultaneous readback from the specified remote SPI is performed, and the incoming bytes are written into the buffer (replacing the transmitted bytes).  This routine does not <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code> or <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a></code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, nor does it modify the configuration of the specified SPI channel or activate any chip selects.  If required, these additional functions must be performed by the calling program.  This routine executes at approximately 7 microseconds per byte with a 2 MHz SPI clock.
</p>
<p>Type: macro
<br/>Related Forth function: <code>SPI.EXCHANGE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> as described above. If only one 
peripheral is connected to an SPI channel, then there is no need to 
save, change or restore the configuration, and the available drivers can
 be used.  If multiple peripherals with different communication 
parameters are interfaced on either the <code>SPI1</code> or <code>SPI2</code> channel, and the same <span class="glossary" id="_1387530954" onclick="msc_positionPopup(this)">TASK</span><span><!--<div id="pop_1387530954" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#task' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>TASK</code>
</p>
<p>A structure typedef that names and allocates a <code>TASK</code> structure (typically decimal 2000 bytes long) in common RAM.  In other words, <code>TASK</code> is used to name and locate a new task.  To declare a new task named AnyTask, use the statement:
</p><pre class="code">
TASK AnyTask;</pre>
<p>Also see the glossary entries for <code>BUILD_C_TASK()</code> and <code>ACTIVATE()</code> for a discussion of how to build and activate the new task.
</p>
<p>See also <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#forth_task" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">FORTH_TASK</a></code>
</p>
<p>Type: typedef
<br/>Related Forth function: <code>ALLOCATE.TASK:</code>
<br/>Header file: user.h
</p></span></span></div>--></span> is responsible for communicating with all of them, then <span class="glossary" id="_1207819939" onclick="msc_positionPopup(this)">SPIConfig()</span><span><!--<div id="pop_1207819939" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spiconfig' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIConfig( int clock_edge_specifier, int spibr_contents, int spi_channel )</code>
</p>
<p>Configures the specified <code>spi_channel</code> (= 0, 1 or 2) based on the specified clock and baud rate input parameters.  The <code>clock_edge_specifier</code> is one of the constants <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> (the default after a power-up or restart for all 3 SPI channels), <code><a href="#spi_rising_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_LEADING_EDGE</a></code>, <code><a href="#spi_falling_leading_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_LEADING_EDGE</a></code>, or <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code>; consult their glossary entries.  The clock idles in the low state for the first two of these clock_edge_specifiers, and idles in the logic high state for the latter two.  Each named constant describes the clock edge at which the data is sampled and valid; the data is typically transferred on the SPI bus one half cycle before the specified edge.  The <code>spibr_contents</code> input parameter is the baud rate specifier.  All other configuration parameters (master/slave, mode fault enable, SPI interrupt enable, bit order, <code>/SS</code> direction) are unchanged by this routine, and typically retain the state set by <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> for the <code>SPI0</code> channel, or <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> for the <code>SPI1</code> and <code>SPI2</code> channels. <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitSPI</a>()</code> is called upon each reset and restart, but <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io#initipspi" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-io">InitIPSPI</a>()</code> is not, and must be explicitly called by application code before calling <code>SPIConfig()</code>; consult their glossary entries for configuration details.  The <code>SPI0</code> channel’s default baud register contents equal <code>0x40</code> after a power-up or restart, corresponding to a 2 Mhz SPI clock frequency.  The default <code><a href="#spi_falling_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_FALLING_TRAILING_EDGE</a></code> with a 2 <abbr title="Megahertz">MHz</abbr> baud rate is a common configuration, and is proper for the on-chip battery-backed Real-Time Clock which shares the <code>SPI0</code> channel.  The <code>SPI0</code> bus is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  The processor’s <code>SPI1</code> and <code>SPI2</code> buses come up at a default baud rate of 5 MHz.  To select a configuration for a given SPI peripheral, consult the peripheral’s data sheet to discover the proper data-valid clock edge and baud rate.  Execute the interactive (Forth) <code>SPI.FREQUENCIES</code> function from the terminal to obtain a printout summarizing the available baud rates and corresponding <code>SPIBR</code> baud register contents; consult the <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> glossary entry.   
</p>
<p>Example of use:  Let’s assume that we are interfacing to an SPI peripheral on <code>SPI0</code> that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz SPI clock frequencies.  Using <code>SPI.FREQUENCIES</code>, we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an spibr_contents parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code>, set the new configuration parameters using <code>SPIConfig()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>      <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific ''SPI0'' peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the <code>SPI0</code> bus, and also prevents contention on the SPI bus because <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Writes to the SPIxCR1 and SPIxBR registers. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.CONFIG</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> may be called as needed to set 
communication parameters for each device before communicating with it 
(and each device must have a slave select line connected to a separate 
digital output pin to avoid having all devices on the bus attempt to 
receive data not intended for them).
</p>
<p>However, if your application design involves multiple <span class="glossary" id="_1753279310" onclick="msc_positionPopup(this)">TASK</span><span><!--<div id="pop_1753279310" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#task' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>TASK</code>
</p>
<p>A structure typedef that names and allocates a <code>TASK</code> structure (typically decimal 2000 bytes long) in common RAM.  In other words, <code>TASK</code> is used to name and locate a new task.  To declare a new task named AnyTask, use the statement:
</p><pre class="code">
TASK AnyTask;</pre>
<p>Also see the glossary entries for <code>BUILD_C_TASK()</code> and <code>ACTIVATE()</code> for a discussion of how to build and activate the new task.
</p>
<p>See also <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#forth_task" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">FORTH_TASK</a></code>
</p>
<p>Type: typedef
<br/>Related Forth function: <code>ALLOCATE.TASK:</code>
<br/>Header file: user.h
</p></span></span></div>--></span>s to communicate on the same SPI channel, then the equivalent of the <span class="glossary" id="_1251526646" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_1251526646" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> and <span class="glossary" id="_1349145064" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_1349145064" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> functions must be created for <code>SPI1</code> and/or <code>SPI2</code>.  This will not be necessary for most applications, but if it proves necessary instructions are provided below.
</p>
<p>Let’s assume that no jumper cap is installed on the <code>SPI #2</code> jumper, so that the <code>SPI1</code> channel is configured as a master by default, and two peripherals communicate with the HCS12 via <code>SPI1</code>
 at different baud rates.  Each of the peripherals must have its own 
chip select, typically implemented as port output bits.  If two separate
 <span class="glossary" id="_1848360894" onclick="msc_positionPopup(this)">TASK</span><span><!--<div id="pop_1848360894" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#task' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>TASK</code>
</p>
<p>A structure typedef that names and allocates a <code>TASK</code> structure (typically decimal 2000 bytes long) in common RAM.  In other words, <code>TASK</code> is used to name and locate a new task.  To declare a new task named AnyTask, use the statement:
</p><pre class="code">
TASK AnyTask;</pre>
<p>Also see the glossary entries for <code>BUILD_C_TASK()</code> and <code>ACTIVATE()</code> for a discussion of how to build and activate the new task.
</p>
<p>See also <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#forth_task" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">FORTH_TASK</a></code>
</p>
<p>Type: typedef
<br/>Related Forth function: <code>ALLOCATE.TASK:</code>
<br/>Header file: user.h
</p></span></span></div>--></span>s are used to access these two peripherals, use the <span class="glossary" id="_594705731" onclick="msc_positionPopup(this)">RESOURCE</span><span><!--<div id="pop_594705731" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#resource' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RESOURCE</code>
</p>
<p>This typedef allocates a 32-bit resource variable in the common RAM.  Use as:
</p><pre class="code">
RESOURCE   &#60;name&#62;; </pre>
<p>where &lt;name&gt; is any name of your choosing.  Resource variables are used in multitasked systems to control access to shared resources (for example, an <abbr title="Analog to Digital (Converter), ADC, ATD, often a hardware module on embedded microcontrollers">A/D</abbr> converter, serial port, block of memory, etc.)   When the resource associated with <code>&lt;name&gt;</code> is available, <code>&lt;name&gt;</code> contains zero.  When it is controlled by a task (and hence unavailable to other tasks), it contains the <code><a href="#taskbase" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TASKBASE</a></code> address of the controlling task; consult the glossary entries for <code><a href="#task" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TASK</a></code> and <code><a href="#taskbase" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TASKBASE</a></code>.  Before its first use, the resource variable must be initialized to zero.  After initialization to zero, the only operators that should access the resource variable are <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> <code><a href="#try_to_get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">TRY_TO_GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code>.  The following resource variables are pre-defined in the mtasker.h file:
</p><pre class="c code c">SPI_RESOURCE      SERIAL
SERIAL1_RESOURCE  SERIAL2_RESOURCE</pre>
<p>See their glossary entries and consult the <a href="/embedded-systems/c-ide-software-development/multitasking-real-time-operating-system-rtos/microcontroller" class="wikilink1" title="c-ide-software-development:multitasking-real-time-operating-system-rtos:microcontroller">Multitasking chapter</a> in the Software Manual for further descriptions and examples of use.
</p>
<p>Type: typedef
<br/>Related Forth function: <code>RESOURCE.VARIABLE:</code>
<br/>Header file: mtasker.h
</p></span></span></div>--></span> typedef to declare a resource variable.  For example,
</p><pre class="c code c">RESOURCE SPI1_RESOURCE <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span></pre>
<p>The 4-byte configuration register area for <code>SPI1</code> starts at <code>0x00F0</code>, and the 4-byte configuration register area for <code>SPI2</code> starts at <code>0x00F8</code>.  To define the equivalent of the <span class="glossary" id="_2089631989" onclick="msc_positionPopup(this)">SPISave()</span><span><!--<div id="pop_2089631989" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spisave' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>ulong SPISave( void )</code>
</p>
<p><code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a></code>s the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>, then fetches and returns as a 32-bit quantity the contents of the four configuration registers of the <code>SPI0</code> (serial peripheral interface 0) channel.  After calling <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> to configure the SPI link and <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> to talk to the specified peripheral, the output parameter should be passed by the application program as the input to <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> which restores the prior configuration and releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make <code>SPI0</code> available to other tasks.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal. 
</p>
<p>Example of use:  Let’s assume that we are interfacing to a peripheral on SPI channel 0 that samples data on the <code><a href="#spi_rising_trailing_edge" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RISING_TRAILING_EDGE</a></code> of a clock that idles high, and can run at up to 100 kHz.  Using <code>SPI.FREQUENCIES</code> or <code><a href="#spifrequencies" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIFrequencies</a>()</code> (see its glossary entry), we note that the fastest attainable baud rate under 100 kHz is 89 kHz, corresponding to an <code>spibr_contents</code> parameter of <code>0x64</code>.  To interact with this peripheral device, we save the current SPI configuration state using <code>SPISave()</code>, set the new configuration parameters using <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code>, communicate with the peripheral by strobing its unique chip select signal and exchanging data using the <code><a href="#spiexchange" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIExchange</a>()</code> function, and restore the prior SPI configuration using <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code>.  To implement this example, execute:
</p><pre class="c code c">ulong prior_spi_state<span class="sy0">;</span>         <span class="co1">// declare a temporary 32-bit variable to hold state</span>
prior_spi_state <span class="sy0">=</span> SPISave<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">// save prior SPI configuration state, executes Get()</span>
SPIConfig<span class="br0">&#40;</span>SPI_RISING_TRAILING_EDGE<span class="sy0">,</span> <span class="nu12">0x64</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// assert the unique chip select for the specific SPI peripheral here and</span>
<span class="co1">// call SPIExchange() as needed to talk to the peripheral</span>
<span class="co1">// de-assert the unique chip select for the specific SPI peripheral here</span>
SPIRestore<span class="br0">&#40;</span>prior_spi_state<span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// restore prior configuration; also does Release()</span></pre>
<p>This approach enables <em>polite</em> reconfiguration of the clock edge and baud rate for various slaves on the SPI bus, and also prevents contention on the SPI bus because <code>SPISave()</code> and <code><a href="#spirestore" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIRestore</a>()</code> correctly <code><a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions">GET</a>()</code> and <code><a href="#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">RELEASE</a>()</code> the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code>. 
</p>
<p>Implementation detail: Gets the <code>SPI.RESOURCE</code> variable, then fetches the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code> and returns them as a 32-bit long. 
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.SAVE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function for <code>SPI1</code>, the function should <span class="glossary" id="_289746248" onclick="msc_positionPopup(this)">GET</span><span><!--<div id="pop_289746248" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>GET ( xresource && )</code>
</p>
<p>Used in a multitasking system to gain access to a shared resource.   PAUSEs until the resource variable whose address is xresource is available, and then GETs the resource by storing the task id (i.e., the <code>STATUS</code> xaddr) of the requesting task into the xresource.  <code>0\0</code> in xresource indicates that the resource is available, and a non-zero value that is not equal to the requesting task&#039;s id indicates that another task controls the resource.   To ensure that the state of the resource is correctly determined, <code>GET</code> disables interrupts for 0.25 to 1microsecond.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-a-d">?GET</a>, <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RELEASE</a>, and <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z">RESOURCE.VARIABLE:</a>
</p>
<p>Attributes: M
</p></span></span></div>--></span> the <code>SPI1_RESOURCE</code> and then fetch the 32-bit contents of the <code>SPI1</code> configuration register area at <code>0x00F0</code>.  To define the equivalent of the <span class="glossary" id="_2050442337" onclick="msc_positionPopup(this)">SPIRestore()</span><span><!--<div id="pop_2050442337" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos#spirestore' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>void SPIRestore( ulong prior_spi_config )</code>
</p>
<p>Stores the specified 4-byte quantity <code>prior_spi_config</code> into the 4 sequential configuration registers of the <code>SPI0</code> channel, and then releases the <code><a href="#spi_resource" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPI_RESOURCE</a></code> to make the <code>SPI0</code> (serial peripheral interface 0) bus available to other tasks.  The input parameter is typically the parameter returned by the <code>SPISave()</code> function, and this <code>SPIRestore()</code> function re-saves the register contents to restore the prior SPI clock edge and baud rate specifications.  <code>SPI0</code> is brought out to the Wildcard bus and is available for communication with various peripherals, provided that each peripheral is selected by a unique chip select signal.  See the glossary entries for <code><a href="#spisave" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPISave</a>()</code> and <code><a href="#spiconfig" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:c-library-hcs12-9s12:c-functions-rtos &crarr;">SPIConfig</a>()</code> for examples of use.
</p>
<p>Note: This function cannot be used with SPI channels 1 and 2.
</p>
<p>Implementation detail: Stores the 4-byte input parameter <code>prior_spi_config</code> into the four sequential <code>SPI0</code> configuration registers <code>SPI0CR1</code>, <code>SPI0CR2</code>, <code>SPI0BR</code>, and <code>SPI0SR</code>, then releases the <code>SPI_RESOURCE</code>. 
</p>
<p>Type: kernel function
<br/>Forth name: <code>SPI.RESTORE</code>
<br/>Header file: serial.h
</p></span></span></div>--></span> function for <code>SPI1</code>, the 
function should accept a 32-bit input parameter (the one generated by 
the save routine) and store it into the configuration register area at <code>0x00F0</code>, and then <span class="glossary" id="_1068558107" onclick="msc_positionPopup(this)">RELEASE</span><span><!--<div id="pop_1068558107" class="glossary_popup">
  <span  class='insitudef'>
    <span class='insitudef_buttons'>
      <a href='/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z#release' target='_blank'
         onclick="this.parentNode.parentNode.parentNode.style.display='none'">More…</a>
      <a onclick="this.parentNode.parentNode.parentNode.style.display='none';">Close</a>
    </span>
    <span class='def'>
<p><code>RELEASE ( xresource && )</code>
</p>
<p>If the current task owns the resource variable referenced by xresource (i.e., if xresource contains the current task&#039;s xtask.id), releases the resource by storing <code>0\0</code> in xresource.   Otherwise, does nothing; this prevents a task from RELEASEing a resource controlled by another task.   Interrupts are not disabled and <code>PAUSE</code> is not executed.
</p>
<p>See also <a href="/embedded-systems/c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o#get" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-e-o">GET</a> and <a href="#resourcevariable" class="wikilink1" title="c-ide-software-development:codeblocks-gnu-c-gcc-compiler:forth-library-hcs12-9s12:forth-words-p-z &crarr;">RESOURCE.VARIABLE:</a>
</p></span></span></div>--></span> the <code>SPI1_RESOURCE</code>.  This approach will enable “polite” reconfiguration of the <code>SPI1</code> channel in a manner exactly analogous to that provided by the pre-coded routines for <code>SPI0</code>.
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<h2 class="sectionedit12" id="summary-of-the-hcs129s12-spi">Summary of the HCS12/9S12 SPI</h2><div class="level2">
<p>The flexibility and power of the HCS12’s serial peripheral interface 
supports high speed communication between the HCS12 and other 
synchronous serial devices.  The interface can be used to support analog
 to digital and digital to analog converters, networks of many computers
 controlled by a single master, or networks of devices controlled by 
several coordinated masters.  Pre-coded device drivers configure the SPI
 for a standard data format, and it is easy to customize a data format 
and baud rate for your application.   With careful design, many 
peripherals can communicate via the SPI, and powerful multi-processor 
systems can be linked using this high speed bus.
</p>
<p><br>
</p><hr>

<p>See also → <a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-i2c-bus" class="wikilink1" title="sbc-single-board-computers:freescale-hcs12-9s12-c-language:instrument-control:microcontroller-i2c-bus">Inter-IC (IIC, I²C, I2C) Serial Bus</a>
</p><a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>

<div class="pgabout llcolor">This page is about: Using Serial Peripheral
 Interface (SPI) for Fast Serial Data Exchange – Using the SPI (serial 
peripheral interface) for fast serial data exchange and multi-drop 
serial communications between the PDQ Board and peripheral devices 
including analog to digital and digital to analog converters, real time 
clocks, sensors and actuators.</div>
</article>
<div class="clearer">&nbsp;</div>
</div>
</div>
<div class="backtotop"><a class="backtotop" onclick="window.scrollTo(0, 0)"></a>
   <div class="linkcolor" style="float:left;margin-top:-5px;"><a class="wikilink1" onclick="window.scrollTo(0, 0)">Back&nbsp;to&nbsp;top&nbsp;</a></div></div>
<div id="m__pgname"><a href="http://www.mosaic-industries.com/embedded-systems/site-map" title="Index to all documents, tutorials, and user guides" target="_blank">Index to all documents, tutorials, and user guides</a></div><div id="tlbr__cntnr">
<div class="tlbr"><div class="tlbrr">
<a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="icn-help" title="Help" rel="nofollow" target="_blank"></a><a href="http://www.mosaic-industries.com/embedded-systems/tpl_discussion" class="icn-comment" title="Comment, ask questions, leave feedback" rel="nofollow" target="_blank"></a><a class="icn-vertbar"></a>
<a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface?do=print_preview" class="icn-print" title="Show a printer friendly page" rel="nofollow" target="_blank"></a><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface?do=backlink" class="action backlink" accesskey="" rel="nofollow" title="Show links to this page"> </a></div>
<nav class="tlbrl">
<a id="leftcolopenclosebtn" class="btn-move-left" title="Hide the left sidebars"></a>
<a class="icn-vertbar"></a><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller" class="action back" accesskey="b" rel="nofollow" title="Go up to: PDQ Board Users Guide"> </a><a class="icn-vertbar"></a>
<a class="icn-firstpage" title="Overview of documents: PDQ Board Users Guide" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller"></a>
<a class="icn-priorpage" title="Previous document: Implementing Logic-Level Serial Ports" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/software-uart-serial" rel="prev"></a>
<a class="icn-nextpage" title="Next document: Inter-IC (IIC, I²C, I2C) Serial Bus" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-i2c-bus" rel="next"></a>
<a class="icn-lastpage" title="Last document: FAQ, Frequently Asked Questions" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/faq"></a>
</nav></div></div>
<div class="sharebtn"><div class="gplusone"><div id="___plusone_1" style="text-indent: 0px; margin: 0px; padding: 0px; background: none repeat scroll 0% 0% transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 24px; height: 15px;"><iframe title="+1" data-gapiattached="true" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/fastbutton_002.html" name="I1_1394802102508" id="I1_1394802102508" vspace="0" tabindex="0" style="position: static; top: 0px; width: 24px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 15px;" marginwidth="0" marginheight="0" hspace="0" scrolling="no" width="100%" frameborder="0"></iframe></div></div></div></div></div></div>
<div id="left__col" style="display: block; width: 224px;">
<div class="sbar rounded tinted __tpl_navigation" style="margin-top:0;"><div class="tglclose" title="Hide" onclick="toggleVisibility(this)"><div>&nbsp;</div>Navigation</div><div style="display:block"><nav class="sb">

<div class="level1"><div class="block" style="margin-top:.5em;padding-left:4px;width:100%;padding-bottom:3px"><span class="inline action16 imglink book"><strong><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" class="wikilink1" title="User manuals and technical support" rel="nofollow">DocWeb Home Page</a></strong></span>
</div><div class="block" style="position:relative;top:-.4em;padding-left:20px;width:100%;padding-top:5px;padding-bottom:3px;border-bottom:1px solid;margin-bottom:-.5em;"><span class="inline file16 imglink txt"><strong><a href="http://www.mosaic-industries.com/embedded-systems/using-the-docweb" class="wikilink1" title="How to use these technical support pages" rel="nofollow">Using this DocWeb</a></strong></span>
</div>
<table class="indexmenu_table"><tbody><tr><td><div style="display: none;" id="nojs_indexmenu_13723864845322c055daaad" class="indexmenu_nojs">

<ul class="idx">
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/microcontroller" class="indexmenu_idx_head" rel="nofollow">Single Board Computers</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/gui-user-interface/microcontroller" class="indexmenu_idx_head" rel="nofollow">GUI/Touchscreen Controllers</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers-instrument-development-kits-new-product-design/microcontroller" class="indexmenu_idx_head" rel="nofollow">Starter Kits</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/modular-power-io-panels/microcontroller" class="indexmenu_idx_head" rel="nofollow">Docking Panels</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/instrumentation/microcontroller" class="indexmenu_idx_head" rel="nofollow">Modular I/O Boards</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/electronic-instrument-design-new-product-development/microcontroller" class="indexmenu_idx_head" rel="nofollow">Accessories</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/c-ide-software-development/microcontroller" class="indexmenu_idx_head" rel="nofollow">Development Software</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/c-tutorial/microcontroller" class="indexmenu_idx_head" rel="nofollow">Software Examples</a></div></li>
<li class="closed"><div class="li"><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller-projects/microcontroller" class="indexmenu_idx_head" rel="nofollow">App Notes &amp; Toolkits</a></div></li></ul>
</div>
<script type="text/javascript">
<!--//--><![CDATA[//><!--
var indexmenu_13723864845322c055daaad = new dTree('indexmenu_13723864845322c055daaad','default');
indexmenu_13723864845322c055daaad.config.urlbase='/embedded-systems/';
indexmenu_13723864845322c055daaad.config.sepchar='/';
indexmenu_13723864845322c055daaad.config.useCookies=false;
indexmenu_13723864845322c055daaad.config.jsajax='%26msort%3Dindexmenu_n%26nsort%3D1';
indexmenu_13723864845322c055daaad.add('',0,-1,'Welcome to Mosaic Documentation Web','microcontroller');
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers',1,0,'Single Board Computers','sbc-single-board-computers/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language',2,1,'PDQ Board','sbc-single-board-computers/freescale-hcs12-9s12-c-language/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/mc9s12a512-mc9s12dp512-datasheets',3,2,'Freescale HCS12 9S12 Datasheets','sbc-single-board-computers/freescale-hcs12-9s12-c-language/mc9s12a512-mc9s12dp512-datasheets/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control',4,2,'PDQ Board Users Guide','sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-projects',5,4,'Overview of Hardware and Software',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-design',6,4,'Getting to Know Your Hardware',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/modular-power-supply',7,4,'Using Your Docking Panel',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/gnu-c-compiler-ide',8,4,'Installing and Connecting to PDQ Board',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-application-programming',9,4,'Your First C Program Using Mosaic IDE Plus',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-compiler-programming',10,4,'Writing and Compiling Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-compile-edit-debug',11,4,'Mosaic IDE Plus',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-debugger',12,4,'Debugging Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-memory-map-eeprom-flash-ram',13,4,'Using Paged Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/real-time-operating-system-rtos',14,4,'Task Switching and Time Keeping',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/isr-interrupt-service-routines',15,4,'Interrupt Service Routines',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-autostart-application',16,4,'Loading Your Program into Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/paged-ram-flash-nonvolatile',17,4,'Storing and Accessing Data in Paged RAM and Flash',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/eeprom-lifetime-reliability-wear-leveling',18,4,'EEPROM Reliability and Wear Leveling',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/watchdog-timer-reset',19,4,'Failure and Run-Time Error Recovery',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/digital-i-o',20,4,'Digital I/O - Reading and Writing',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/interfacing-hardware-digital-io',21,4,'Digital I/O - Hardware Interfacing',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/pulse-width-modulation-pwm-motor-control',22,4,'Pulse Width Modulated I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-input-capture-output-compare-pwm-pulse-counter-frequency-meter',23,4,'Timer-Controlled I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/analog-data-acquisition-10-bit-adc',24,4,'Data Acquisition Using Analog to Digital Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/rs232-serial-rs485-protocol-uart-usart',25,4,'Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/rs232-serial-rs485-protocol-uart-usart-buffered',26,4,'Using Queued Serial',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/software-uart-serial',27,4,'Implementing Logic-Level Serial Ports',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface',28,4,'Serial Peripheral Interface (SPI)',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-i2c-bus',29,4,'Inter-IC (IIC, I²C, I2C) Serial Bus',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/i2c-bus-specifications',30,4,'I2C Bus Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-rtc-real-time-clock-battery',31,4,'Using Battery-Backed Calendar Time Clock',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-c-coding-c-example-program',32,4,'A Turnkeyed C Application Program',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-forth-language',33,4,'A Brief Introduction to Forth Programming',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/forth-language-program-development',34,4,'Advanced Forth Programming Topics',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/forth-real-time-operating-system',35,4,'Multitasking in Forth',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-forth-language-forth-example-program',36,4,'A Turnkeyed Forth Application Program',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/paged-memory-code-relocation',37,4,'For Experts: Compilation and Segment Management',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-specifications',38,4,'Appendix A: PDQ Board (9S12 HCS12) Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/input-output-connectors',39,4,'Appendix B: Connector Pinouts',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-schematics',40,4,'Appendix C: Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/programming-tips',41,4,'Checklist',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/compiler-error-messages',42,4,'Error Messages',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/faq',43,4,'FAQ, Frequently Asked Questions',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/hcs12-9s12-an-introduction-to-software-and-hardware-interfacing',44,2,'PDQ Board Overview',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/measurement-control-i-o-cards',45,2,'Compatible Accessories',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/freescale-hcs12-9s12-c-language/mc9s12dp512-microcontroller-schematic',46,2,'The MC9S12A512 Processor',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board',47,1,'PDQ Board Lite','sbc-single-board-computers/hcs12-9s12-freescale-development-board/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board/microcontroller-projects',48,47,'Overview and Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board/microcontroller-design',49,47,'Getting to Know Your Hardware',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board/c-application-programming',50,47,'Programming PDQ Board Lite',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board/on-chip-memory-map',51,47,'Memory Allocation',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/hcs12-9s12-freescale-development-board/connector-pinouts',52,47,'Connector Pinouts',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language',53,1,'QCard Controller','sbc-single-board-computers/68hc11-c-language/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control',54,53,'QCard Users Guide','sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-projects',55,54,'Getting to Know Your QCard Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/modular-power-supply',56,54,'Using Your PowerDock',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/c-application-programming',57,54,'Your First Program',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-memory-map-eeprom-flash-ram',58,54,'An Introduction to Extended Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/real-time-operating-system-rtos',59,54,'An Introduction to Multitasking',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/c-language-embedded-integrated-development-environment',60,54,'Using IDE',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-paged-memory-eeprom-flash-ram',61,54,'Making Effective Use of Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/real-time-multitasking-controllers-task-switching-time-keeping',62,54,'Task Switching and Time Keeping',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/real-time-multitasking-controllers-interrupt-service-routine',63,54,'Interrupt Service Routines',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/watchdog-timer-error-free-applications-low-power-cpu',64,54,'Failure and Run-Time Error Recovery',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-digital-i-o-input-capture-output-compare-pwm-pulse-counter-frequency-meter',65,54,'Digital and Timer-Controlled I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/i-o-pin-electrical-specifications',66,54,'Digital I/O Connections',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/programmable-duty-cycle-pwm-waveform-low-jitter',67,54,'Pulse and PWM Generation Techniques',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/analog-data-acquisition-8-bit-adc',68,54,'Data Acquisition Using Analog to Digital Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/rs232-rs485-serial-uart',69,54,'Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-rtc-real-time-clock-battery',70,54,'The Battery-Backed Real-Time Clock',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-c-coding-c-example-program',71,54,'A Turnkeyed C Application Program',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/power-microcontroller-specifications',72,54,'Appendix A: QCard Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/input-output-connectors',73,54,'Appendix B: Connector Pinouts',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/microcontroller-schematics',74,54,'Appendix C: Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/instrument-control/board-mechanical-drawings',75,54,'Appendix D: Dimensions and Drawings',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/measurement-control-i-o-cards',76,53,'Compatible Accessories',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers/68hc11-c-language/datasheets',77,53,'M68HC11 Datasheets',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface',78,0,'GUI/Touchscreen Controllers','gui-user-interface/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel',79,78,'QScreen Controller','gui-user-interface/68hc11-lcd-touch-panel/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control',80,79,'QScreen Controller Users Guide','gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-product-design-development',81,80,'Getting to Know Your QScreen Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/c-application-programming',82,80,'Your First Program',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/c-compiler-editor-ide-program-development',83,80,'The IDE: Writing, Compiling, Downloading and Debugging Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-paged-memory-eeprom-flash-ram',84,80,'Making Effective Use of Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/rtos-real-time-operating-system-multitasking-controllers-interrupt-service-routine',85,80,'Real Time Programming',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-watchdog-timer-reset',86,80,'Failure and Run-Time Error Recovery',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-digital-i-o-input-capture-output-compare-pwm-pulse-counter-timer-frequency-meter',87,80,'Digital and Timer-Controlled I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-analog-data-acquisition-8-bit-16-bit-adc',88,80,'Data Acquisition Using Analog to Digital Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/spi-rs232-serial-rs485-protocol-uart-usart',89,80,'Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-rtc-real-time-clock-battery',90,80,'The Battery-Backed Real-Time Clock and Beeper',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/turnkey-c-application-programming',91,80,'A Turnkeyed Application',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-specifications',92,80,'Appendix A: QScreen Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-connectors',93,80,'Appendix B: Connector Pinouts',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-control/microcontroller-circuit-schematics',94,80,'Appendix C: Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/development-tools',95,79,'Development Tools','gui-user-interface/68hc11-lcd-touch-panel/development-tools/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/development-tools/microcontroller-memory-dump',96,95,'Recover QScreen Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/instrument-controllers',97,79,'Compatible Accessories',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/68hc11-lcd-touch-panel/c-library-gui',98,79,'QScreen Software GUI Toolkit Documentation',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd',99,78,'Handheld (Legacy)','gui-user-interface/portable-handheld-computer-lcd/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control',100,99,'Handheld Users Guide','gui-user-interface/portable-handheld-computer-lcd/instrument-control/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/keypad-display-backlight',101,100,'Getting to Know Your Handheld Instrument',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/rechargeable-battery-powered-low-power',102,100,'Powering Your Handheld',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/c-application-programming',103,100,'Your First Program',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/c-compiler-microcontroller-ide',104,100,'The IDE: Writing, Compiling, Downloading and Debugging Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/microcontroller-memory-map-eeprom-flash-ram',105,100,'Making Effective Use of Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/real-time-operating-system-rtos',106,100,'Real Time Programming',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/microcontroller-watchdog-timer-reset',107,100,'Failure and Run-Time Error Recovery',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/gui-programming-keypad-graphical-lcd',108,100,'Programming Graphical User Interface',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/microcontroller-digital-i-o-input-capture-output-compare-pwm-pulse-counter-frequency-meter',109,100,'Digital and Timer-Controlled I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/analog-data-acquisition-8-bit-16-bit-adc',110,100,'Data Acquisition Using Analog to Digital Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/spi-rs232-serial-rs485-protocol-uart-usart',111,100,'Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/microcontroller-rtc-real-time-clock-battery',112,100,'Real-Time Clock',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-control/custom-hardware-sensors-mounting',113,100,'Customizing Your Handheld Instrument',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/portable-handheld-computer-lcd/instrument-controllers',114,99,'Compatible Accessories',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen',115,78,'QVGA (Legacy)','gui-user-interface/qvga-lcd-touchscreen/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control',116,115,'QVGA Controller Users Guide','gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-product-design-development',117,116,'Getting to Know Your QVGA Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/c-application-programming',118,116,'Your First Program',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/c-compiler-editor-ide-program-development',119,116,'The IDE: Writing, Compiling, Downloading and Debugging Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-paged-memory-eeprom-flash-ram',120,116,'Making Effective Use of Memory',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/gui-touchscreen-programming-graphical-lcd-gui-toolkit',121,116,'Programming Graphical User Interface',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/rtos-real-time-operating-system-multitasking-controllers-interrupt-service-routine',122,116,'Real Time Programming',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-watchdog-timer-reset-error-recovery',123,116,'Run-Time Error Recovery',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-digital-i-o-input-capture-output-compare-pwm-pulse-width-modulation-pulse-counter-timer',124,116,'Digital and Timer-Controlled I/O',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-analog-data-acquisition-8-bit-16-bit-24-bit-adc',125,116,'Data Acquisition Using Analog to Digital Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/8-bit-multiplying-dac-audio-digital-to-analog-converter',126,116,'Outputting Voltages with Digital to Analog Conversion',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/spi-rs232-serial-rs485-protocol-uart-usart',127,116,'Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-rtc-real-time-clock-battery',128,116,'Battery-Backed RTC',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/c-application-programming-c-examples',129,116,'A Turnkeyed Application',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-specifications',130,116,'Appendix A: QVGA Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-connectors-i-o-pins',131,116,'Appendix B: Connector Pinouts',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/pcb-board-physical-dimensions-mounting',132,116,'Appendix C: Physical Dimensions',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-control/microcontroller-circuit-schematics',133,116,'Appendix D: QVGA Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/c-library-gui',134,115,'QVGA GUI Toolkit','gui-user-interface/qvga-lcd-touchscreen/c-library-gui/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/c-library-gui/c-function-summary',135,134,'GUI Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/c-library-gui/c-functions-reference',136,134,'GUI Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('gui-user-interface/qvga-lcd-touchscreen/instrument-operator-interface',137,115,'Compatible Accessories',0,0,0);
indexmenu_13723864845322c055daaad.add('sbc-single-board-computers-instrument-development-kits-new-product-design',138,0,'Starter Kits','sbc-single-board-computers-instrument-development-kits-new-product-design/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('modular-power-io-panels',139,0,'Docking Panels','modular-power-io-panels/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation',140,0,'Modular I/O Boards','instrumentation/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/opto-isolated-high-current-driver-digital-output-ssr',141,140,'Power I/O Wildcard','instrumentation/opto-isolated-high-current-driver-digital-output-ssr/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/opto-isolated-high-current-driver-digital-output-ssr/motor-control',142,141,'Power I/O Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/opto-isolated-high-current-driver-digital-output-ssr/instrument-controllers',143,141,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/opto-isolated-high-current-driver-digital-output-ssr/c-examples',144,141,'Power I/O C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/opto-isolated-high-current-driver-digital-output-ssr/forth-examples',145,141,'Power I/O Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi',146,140,'Ethersmart-WiFi Software Drivers','instrumentation/lantronix-xport-wiport-ethernet-wifi/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-library-firmware',147,146,'Ethernet WiFi Device Driver Library','instrumentation/lantronix-xport-wiport-ethernet-wifi/c-library-firmware/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-library-firmware/device-servers-functions',148,147,'EtherSmart/WiFi Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-library-firmware/c-functions',149,147,'EtherSmart/WiFi Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples',150,146,'Demos and Examples','instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples/webserver-embedded-email-server',151,150,'Ether/WiFi C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples/remote-access-control-server',152,150,'C Language Remote Front Panel Demo for QScreen / QVGA Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples/forth-language-webserver-embedded-email',153,150,'Ether/Wifi Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/c-examples/forth-language-remote-access-control-server',154,150,'Forth Remote Front Panel Demo for QScreen / QVGA Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/serial-tcp-ip-lan-wan-network',155,146,'Ethernet-WiFi Device Driver Data Structures',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/tcp-ip-http-internet-protocol',156,146,'Using Embedded Web and Email Servers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/internet-explorer-firefox-chrome-browser',157,146,'Browsing into Remote Device',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/embedded-email-embedded-web-server-firmware',158,146,'Installing Device Drivers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/device-servers-example',159,146,'Installing and Running Example Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/tcp-ip-address-ping',160,146,'Using Example Application',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/tcp-ip-rs232-serial-to-ethernet-to-serial-tunneling',161,146,'Serial Tunneling',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/embedded-email-wireless-smtp-lan-wan',162,146,'Setting up Embedded Email Server',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/dynamic-embedded-webserver-device-webservers',163,146,'Setting-up Dynamic Embedded Web Server',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-wiport-ethernet-wifi/remote-webserver-device-remote-control-access-management',164,146,'Implementing Remote Instrument Front Panel',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-ethernet-device-servers',165,140,'Ethersmart Wildcard','instrumentation/lantronix-xport-ethernet-device-servers/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-ethernet-device-servers/serial-uart-usart-rj45-circuit-schematic',166,165,'EtherSmart Hardware Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-ethernet-device-servers/compatible-ethx',167,165,'Ethersmart Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-xport-ethernet-device-servers/serial-uart-usart-rj45',168,165,'Installing and Using Your EtherSmart Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers',169,140,'WiFi Wildcard','instrumentation/lantronix-wiport-wifi-device-servers/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers/wireless-serial-uart-usart-antenna-circuit-schematic',170,169,'WiFi Wildcard Hardware Schematics',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers/serial-to-ethernet-lan-tcp-ip',171,169,'WiFi Access Point Configuration',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers/serial-to-ethernet-lan-tcp-ip-antenna',172,169,'Installing and Using Your WiFi Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers/compatible-wifi',173,169,'WiFi Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/lantronix-wiport-wifi-device-servers/lan-wan-ssid-security',174,169,'WiFi Configuration and Security',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/pulse-width-modulation-pwm-controller-driver-actuator',175,140,'PWM Driver Wildcard','instrumentation/pulse-width-modulation-pwm-controller-driver-actuator/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/pulse-width-modulation-pwm-controller-driver-actuator/circuit-schematic',176,175,'Using PWM Driver Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/pulse-width-modulation-pwm-controller-driver-actuator/noise-reduction',177,175,'Preventing PWM Noise',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/pulse-width-modulation-pwm-controller-driver-actuator/high-frequency',178,175,'Using High Frequency PWM',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/pulse-width-modulation-pwm-controller-driver-actuator/pic-microcontroller',179,175,'Using PWM Driver with Other Microcontrollers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger',180,140,'USB Wildcard','instrumentation/remote-usb-instrument-usb-data-logger/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/functions',181,180,'USB Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/instrument-controllers',182,180,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/instrument-control',183,180,'USB Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/c-functions',184,180,'USB Wildcard Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/c-examples',185,180,'USB C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/remote-usb-instrument-usb-data-logger/forth-examples',186,180,'USB Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thorlabs-meadowlark-lcvr-liquid-crystal-variable-retarder-controller',187,140,'LCVR Driver','instrumentation/thorlabs-meadowlark-lcvr-liquid-crystal-variable-retarder-controller/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thorlabs-meadowlark-lcvr-liquid-crystal-variable-retarder-controller/lc-driver-manual',188,187,'Using LCVR Driver',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thorlabs-meadowlark-lcvr-liquid-crystal-variable-retarder-controller/specifications',189,187,'LCVR Controller Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thermocouple-measurement',190,140,'Thermocouple Wildcard','instrumentation/thermocouple-measurement/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thermocouple-measurement/how-to-guide',191,190,'Thermocouple Measurement Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/thermocouple-measurement/c-functions-temperature-measurement',192,190,'Thermocouple Measurement C Functions',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/screw-terminal-blocks',193,140,'Screw Terminal Wildcard','instrumentation/screw-terminal-blocks/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/screw-terminal-blocks/instrument-controllers',194,193,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/screw-terminal-blocks/instrument-control-connections',195,193,'Using Screw Terminal Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart',196,140,'UART Wildcard','instrumentation/rs232-serial-rs485-protocol-uart-usart/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/instrument-controllers',197,196,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/uart-driver-functions',198,196,'UART Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/forth-examples',199,196,'UART Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/instrument-control',200,196,'UART Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/c-library-uart-functions',201,196,'UART Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/c-examples',202,196,'UART C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/rs232-serial-rs485-protocol-uart-usart/understanding-serial-communications',203,196,'Understanding Serial Communications',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger',204,140,'GPS Wildcard','instrumentation/garmin-gps-board-global-positioning-system-data-logger/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/gps-functions',205,204,'GPS Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/portable-instruments',206,204,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/c-library-gps-functions',207,204,'GPS Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/portable-instrument-control',208,204,'GPS Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/c-examples',209,204,'GPS C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/garmin-gps-board-global-positioning-system-data-logger/forth-examples',210,204,'GPS Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/electronic-breadboard-prototyping',211,140,'Prototyping Wildcard','instrumentation/electronic-breadboard-prototyping/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/electronic-breadboard-prototyping/instrument-control',212,211,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/electronic-breadboard-prototyping/instrument-development',213,211,'Prototyping Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs',214,140,'DC Relay Wildcard','instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs/instrument-control',215,214,'DC Relay Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs/instrument-controllers',216,214,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs/c-examples',217,214,'DC Relay C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-dc-opto-isolated-solid-state-relays-ssrs/forth-examples',218,214,'DC Relay Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs',219,140,'AC Relay Wildcard','instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs/instrument-control',220,219,'AC Relay Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs/instrument-controllers',221,219,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs/c-examples',222,219,'AC Relay C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/crydom-ac-opto-isolated-solid-state-relays-ssrs/forth-examples',223,219,'AC Relay Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter',224,140,'Conductivity Sensing Wildcard','instrumentation/conductivity-meter/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/fluid-conductivity-calculation',225,224,'Driver Software',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/microfabricated-planar-interdigitated-electrodes-cell-constant',226,224,'Cell Constant of Interdigitated Electrodes',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/calibration-equations',227,224,'Driver Software Equations',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/manual-conductance-measurement',228,224,'Stand-alone Operation',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/two-electrode-cell-constant',229,224,'Cell Constant of Parallel Wire Electrodes',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/measurement-conductance-cell-constant',230,224,'Using Conductivity Sensing Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/conductance-sensor-probe',231,224,'Conductivity Sensor Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/electrode-surface-area',232,224,'Enhancing Electrode Surface Area',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/total-dissolved-solids',233,224,'Measuring Total Dissolved Solids',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/conductivity-meter/graphite-electrode-cell-constant',234,224,'Cell Constant of Commercial Graphite Probe',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad',235,140,'Keypad/Display Wildcard','instrumentation/4-x-20-lcd-display-backlight-keypad/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/forth-functions',236,235,'Keypad/Display Forth Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/instrument-control-front-panel',237,235,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/instrument-display',238,235,'Keypad Display Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/c-functions',239,235,'Keypad/Display C Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/c-examples',240,235,'Keypad Display C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/4-x-20-lcd-display-backlight-keypad/forth-examples',241,235,'Keypad Display Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac',242,140,'Analog I/O Wildcard','instrumentation/data-acquisition-16-bit-adc-12-bit-dac/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac/instrument-control',243,242,'Analog I/O Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac/c-library-analog-io',244,242,'Analog I/O C Library',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac/c-examples',245,242,'Analog I/O C Example',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac/forth-examples',246,242,'Analog I/O Forth Example',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-16-bit-adc-12-bit-dac/measurement-and-control',247,242,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end',248,140,'DA 24/7 Wildcard','instrumentation/data-acquisition-24-bit-adc-analog-front-end/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/instrument-control',249,248,'24/7 Data Acquisition Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/c-library',250,248,'24/7 Data Acquisition Wildcard Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/c-examples-bipolar-sample',251,248,'DA 24/7 C Demo 1',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/c-examples-calibration',252,248,'DA 24/7 C Demo 3',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/c-examples-continuous-sampling',253,248,'DA 24/7 C Demo 2',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/forth-examples-bipolar-sample',254,248,'DA 24/7 Forth Demo 1',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/forth-examples-multiple-samples',255,248,'DA 24/7 Forth Demo 2',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/forth-examples-calibration',256,248,'DA 24/7 Forth Demo 3',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-24-bit-adc-analog-front-end/measurement-and-control',257,248,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/digital-io-card-digital-control-board',258,140,'Digital I/O Wildcard','instrumentation/digital-io-card-digital-control-board/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/digital-io-card-digital-control-board/instrument-control',259,258,'Digital I/O Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/digital-io-card-digital-control-board/instrument-controllers',260,258,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/digital-io-card-digital-control-board/c-examples',261,258,'Digital I/O C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/digital-io-card-digital-control-board/forth-examples',262,258,'Digital I/O Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-analog-filter-protection',263,140,'I/O Filter Wildcard','instrumentation/data-acquisition-signal-conditioning-analog-filter-protection/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-analog-filter-protection/analog-front-end',264,263,'I/O Filter Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-analog-filter-protection/measurement-and-control',265,263,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-amplifier-4-20-ma',266,140,'Signal Conditioning Wildcard','instrumentation/data-acquisition-signal-conditioning-amplifier-4-20-ma/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-amplifier-4-20-ma/analog-front-end',267,266,'Signal Conditioning Wildcard User Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-signal-conditioning-amplifier-4-20-ma/measurement-and-control',268,266,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system',269,140,'Compact Flash Wildcard','instrumentation/data-acquisition-data-logging-compact-flash-file-system/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system/instrument-controllers',270,269,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system/fat-file-system-instrument-control',271,269,'Compact Flash Wildcard Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system/c-functions-compact-flash-fat-file-system',272,269,'Compact Flash Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system/c-examples',273,269,'Compact Flash C Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/data-acquisition-data-logging-compact-flash-file-system/forth-examples',274,269,'Compact Flash Forth Demo',0,0,0);
indexmenu_13723864845322c055daaad.add('instrumentation/2x16-4x20-lcd-serial-displays-backlight',275,140,'Serial LCD Character Displays','instrumentation/2x16-4x20-lcd-serial-displays-backlight/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development',276,0,'Accessories','electronic-instrument-design-new-product-development/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/power-supplies',277,276,'Power Supplies','electronic-instrument-design-new-product-development/power-supplies/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/touchscreen-protectors',278,276,'Screen Protector','electronic-instrument-design-new-product-development/touchscreen-protectors/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/touchscreen-protectors/instrument-control-front-panel',279,278,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/physical-dimensions',280,276,'Board Dimensions and Mounting','electronic-instrument-design-new-product-development/physical-dimensions/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/environmental-gaskets',281,276,'Environmental Gaskets','electronic-instrument-design-new-product-development/environmental-gaskets/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/environmental-gaskets/instrument-enclosures',282,281,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/enclosures',283,276,'Enclosures','electronic-instrument-design-new-product-development/enclosures/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/enclosures/nema-4x-enclosure',284,283,'NEMA-4X Enclosure',0,0,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/enclosures/instrument-control',285,283,'Compatible Controllers',0,0,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/enclosures/black-anodized-aluminum-bezels',286,283,'Black Anodized Aluminum Bezels',0,0,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/cables',287,276,'Cables','electronic-instrument-design-new-product-development/cables/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('electronic-instrument-design-new-product-development/cables/ribbon-cable-current-rating',288,287,'Ribbon Cable Current Rating',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development',289,0,'Development Software','c-ide-software-development/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler',290,289,'Mosaic IDE','c-ide-software-development/c-compiler/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44',291,290,'Forth V4.4 Language Reference','c-ide-software-development/c-compiler/forth-library-v44/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/forth-words-source-code',292,291,'Forth V4.4 Source-form Functions',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/forth-functions',293,291,'Forth V4.4 Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/c-functions-debugger',294,291,'Forth V4.4 Functions for C Debugging',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/forth-functions-assembler',295,291,'Forth V4.4 Assembler Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/68hc11-functions',296,291,'Forth V4.4 Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/68hc11-interrupts',297,291,'Forth V4.4 Functions that Disable Interrupts',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v44/68hc11-new-functions',298,291,'Forth V4.4 Changes from Prior Kernels',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4',299,290,'Forth V4.08 Language Reference','c-ide-software-development/c-compiler/forth-library-v4/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/forth-functions',300,299,'Forth V4.08 Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/forth-words-source-code',301,299,'Forth V4.08 Source-form Functions',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/forth-functions-assembler',302,299,'Forth V4.08 Assembler Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/68hc11-interrupts',303,299,'Forth V4.08 Functions that Disable Interrupts',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/68hc11-functions',304,299,'Forth V4.08 Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/forth-library-v4/c-functions-debugger',305,299,'Forth V4.08 Functions for C Debugging',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v44',306,290,'C V4.4 Language Reference','c-ide-software-development/c-compiler/c-library-v44/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v44/c-functions',307,306,'C V4.4 Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v44/68hc11-functions',308,306,'C V4.4 Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v44/c-functions-debugger',309,306,'C V4.4 Interactive Debugger Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v4',310,290,'C V4.08 Language Reference','c-ide-software-development/c-compiler/c-library-v4/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v4/c-functions',311,310,'C V4.08 Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v4/68hc11-functions',312,310,'C V4.08 Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/c-library-v4/c-functions-debugger',313,310,'C V4.08 Interactive Debugger Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/v441-kernel-code',314,290,'Kernel V4.41 Upgrade',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/68hc11-programming-tips',315,290,'Tips and Tricks',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/68hc11-c-makefile-c-linker',316,290,'Custom Makefile',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/bugs',317,290,'Bugs and Gotchas',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/c-compiler/libraries',318,290,'Kernel Extensions',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/forth-language',319,289,'Forth Language','c-ide-software-development/forth-language/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/forth-language/stack',320,319,'Stack Symbols &amp; Naming Conventions',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/forth-language/assembler',321,319,'Using Forth Assembler',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler',322,289,'Mosaic IDE Plus','c-ide-software-development/codeblocks-gnu-c-gcc-compiler/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12',323,322,'Forth Language Reference','c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-functions-assembler',324,323,'Forth V6 Assembler Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/interrupts',325,323,'Functions that Disable Interrupts',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-function-list',326,323,'Forth Function List',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-function-library',327,323,'Forth V6 Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/c-functions-debugger',328,323,'Forth V6 Functions for C Debugging',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/new-functions',329,323,'Forth V6 New Features',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words',330,323,'Forth V6 Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-a-d',331,323,'Forth V6 Function Glossary (!-A-D)',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-e-o',332,323,'Forth V6 Function Glossary (E-O)',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/forth-library-hcs12-9s12/forth-words-p-z',333,323,'Forth V6 Function Glossary (P-Z-})',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12',334,322,'C Language Reference','c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-function-summary',335,334,'C Function Summary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions',336,334,'C Function Glossary (A-H)',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-io',337,334,'C Function Glossary (I-Q)',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-rtos',338,334,'C Function Glossary (R-Z)',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/c-functions-debugger',339,334,'Interactive Debugger Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/stack-space',340,334,'Determining Worst-Case Stack Depth',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-library-hcs12-9s12/new-functions',341,334,'Changes from Prior C IDE',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/hcs12-9s12-download',342,322,'1: Using IDE Plus',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/integrated-development-environment',343,322,'2: Setting up Your Project',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/c-code-development',344,322,'3: Coding Your Application',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/paged-memory-variables',345,322,'4: Additional Information for Advanced Users',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/codeblocks-gnu-c-gcc-compiler/bugs',346,322,'Bugs and Gotchas',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/multitasking-real-time-operating-system-rtos',347,289,'Using Multitasking RTOS','c-ide-software-development/multitasking-real-time-operating-system-rtos/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/multitasking-real-time-operating-system-rtos/preemptive-cooperative-task-switching',348,347,'Multitasking Basics',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/multitasking-real-time-operating-system-rtos/c-programming',349,347,'Using Multitasker in C',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/multitasking-real-time-operating-system-rtos/shared-resources',350,347,'Shared Resources',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/multitasking-real-time-operating-system-rtos/semaphores-mailboxes',351,347,'Using Mailboxes in Multitasking C Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/microcontroller-terminal',352,289,'Mosaic Terminal','c-ide-software-development/microcontroller-terminal/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-ide-software-development/microcontroller-terminal/microcontroller-command-line',353,352,'Mosaic Terminal Users Guide',0,0,0);
indexmenu_13723864845322c055daaad.add('c-tutorial',354,0,'Software Examples','c-tutorial/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-tutorial/9s12-hcs12-c-programming-examples',355,354,'PDQ Board C Code Examples','c-tutorial/9s12-hcs12-c-programming-examples/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('c-tutorial/68hc11-c-programming-examples',356,354,'QCard C Code Examples','c-tutorial/68hc11-c-programming-examples/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects',357,0,'App Notes &amp; Toolkits','microcontroller-projects/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/measurement-techniques',358,357,'Measurement Techniques','microcontroller-projects/measurement-techniques/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/measurement-techniques/instrumentation-amplifier-ground-loop-isolator',359,358,'Precision Measurement without Ground Offsets',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/stepper-motors',360,357,'Stepper Motor Control','microcontroller-projects/stepper-motors/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/stepper-motors/specifications',361,360,'Stepper Motor Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/stepper-motors/control-software-driver',362,360,'Controlling Stepper Motors Using Power IO Wildcard',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/stepper-motors/c-functions',363,360,'Stepper Motor Control Function Glossary',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/stepper-motors/forth-c-examples',364,360,'Example Stepper Motor Control Programs',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement',365,357,'Measuring Temperature','microcontroller-projects/temperature-measurement/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple',366,365,'Using Thermocouples','microcontroller-projects/temperature-measurement/thermocouple/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/types-wire-element',367,366,'Thermocouple Types',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/calibration-table',368,366,'Efficient Thermocouple Calibration and Measurement',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-b-calibration-table',369,366,'Type B Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-e-calibration-table',370,366,'Type E Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-j-calibration-table',371,366,'Type J Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-k-calibration-table',372,366,'Type K Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-n-calibration-table',373,366,'Type N Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-r-calibration-table',374,366,'Type R Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-s-calibration-table',375,366,'Type S Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/type-t-calibration-table',376,366,'Type T Thermocouple Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/cold-junction-compensation',377,366,'Cold Junction Compensation',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/amplifier-circuit-schematic',378,366,'Connecting Thermocouples',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/thermocouple/thermocouple-noise-filter',379,366,'Thermocouple Noise Filtering',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/platinum-rtd-sensors',380,365,'Using RTDs','microcontroller-projects/temperature-measurement/platinum-rtd-sensors/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/platinum-rtd-sensors/resistance-calibration-table',381,380,'RTD Calibration',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/platinum-rtd-sensors/resistance-accuracy',382,380,'RTD Accuracy and Tolerances',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/platinum-rtd-sensors/noise-filtering',383,380,'Noise Filtering for RTDs',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/platinum-rtd-sensors/amplifier-circuit-schematics',384,380,'Measuring RTDs',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/ntc-thermistors',385,365,'Using Thermistors','microcontroller-projects/temperature-measurement/ntc-thermistors/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/ntc-thermistors/resistance-equation',386,385,'Temperature Resistance Equation',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/ntc-thermistors/circuit-schematics',387,385,'Measuring Thermistors',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/ntc-thermistors/example-code-equations',388,385,'Efficient Thermistor Temperature Computation',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/microchip-tc74-temperature-sensor-datasheet-i2c',389,365,'Using I2C Temperature Sensors',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/temperature-measurement/lm335-lm35-temperature-sensor-ic',390,365,'Using LM335 IC Temperature Sensor',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/measure-distance',391,357,'Measuring Distance','microcontroller-projects/measure-distance/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/measure-distance/sharp-gp2d12-ir-distance-sensor',392,391,'How to Measure Analog Distance Sensor',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/frequency-measurement',393,357,'Measuring Frequency','microcontroller-projects/frequency-measurement/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/frequency-measurement/9s12-hcs12-pulse-accumulator-c-example',394,393,'Frequency Measurement Using Microcontrollers',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/reducing-emi',395,357,'Reducing EMI','microcontroller-projects/reducing-emi/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/reducing-emi/slew-rate-limiter',396,395,'Slew-Rate Control Reduces EMI',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/circuit-protection',397,357,'Circuit Protection','microcontroller-projects/circuit-protection/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/circuit-protection/atd-inputs',398,397,'A/D Protection Circuits',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits',399,357,'Electronic Circuits for Instruments','microcontroller-projects/electronic-circuits/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/push-button-switch-turn-on',400,399,'Push Button ON/OFF Power Control Using MOSFETs','microcontroller-projects/electronic-circuits/push-button-switch-turn-on/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/push-button-switch-turn-on/latching-toggle-power-switch',401,400,'Latch and Toggle Power Circuits',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/push-button-switch-turn-on/inrush-current-limited-mosfet',402,400,'Limiting In-rush Current in MOSFET Power Switches',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/push-button-switch-turn-on/microcontroller-latching-on-off',403,400,'Controlled Turn-ON and Shutdown of Microcontroller Products',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/push-button-switch-turn-on/switching-battery-power',404,400,'Battery Operated Latching Power Switch',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/program-regulator-voltage',405,399,'Dynamically Program Voltage Regulators',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/step-down-switching-regulator',406,399,'Designing Step-Down (Buck) Switching Regulators',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/using-power-mosfets',407,399,'Using Power MOSFETs',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/matrix-keypad-scan-decode',408,399,'Keypad Scan Uses Few I/O Lines',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/electronic-circuits/open-collector-outputs',409,399,'Simulating Open Collector Outputs',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/raspberry-pi',410,357,'Raspberry Pi','microcontroller-projects/raspberry-pi/microcontroller',1,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/raspberry-pi/on-off-power-controller',411,410,'Raspberry Pi ON/OFF Power Controller',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/raspberry-pi/gpio-pin-electrical-specifications',412,410,'GPIO Electrical Specifications',0,0,0);
indexmenu_13723864845322c055daaad.add('microcontroller-projects/microcontroller-videos-youtube',413,357,'Microcontroller Projects',0,0,0);
document.write(indexmenu_13723864845322c055daaad);
addInitEvent(function(){indexmenu_13723864845322c055daaad.init(0,1,"",1,0);});
//--><!]]>
</script><div id="cdtree_indexmenu_13723864845322c055daaad" class="dtree" style="position:relative;overflow:hidden;width:100%;"><div id="dtree_indexmenu_13723864845322c055daaad" class="dtree default" style="overflow:visible;position:relative;width:100%"><div id="tindexmenu_13723864845322c055daaad" class="indexmenu_tocbullet default" style="display:none;" title="Page contents"></div><div id="toc_indexmenu_13723864845322c055daaad" style="display:none;"></div><div class="dTreeNode"><img id="iindexmenu_13723864845322c055daaad0" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/base.gif" alt=""><a id="sindexmenu_13723864845322c055daaad0" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/microcontroller" title="Welcome to Mosaic Documentation Web" onmouseover="indexmenu_13723864845322c055daaad.show_feat('0');" onmousedown="return indexmenu_checkcontextm('0',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(0);">Welcome to Mosaic Documentation Web</a></div><div id="dindexmenu_13723864845322c055daaad0" class="clip" style="display:block;"><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(1);"><img id="jindexmenu_13723864845322c055daaad1" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/minus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad1" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderhopen.gif" alt=""><a id="sindexmenu_13723864845322c055daaad1" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/microcontroller" title="Single Board Computers" onmouseover="indexmenu_13723864845322c055daaad.show_feat('1');" onmousedown="return indexmenu_checkcontextm('1',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(1);">Single Board Computers</a></div><div id="dindexmenu_13723864845322c055daaad1" class="clip" style="display: block;"><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><a href="javascript:%20indexmenu_13723864845322c055daaad.o(2);"><img id="jindexmenu_13723864845322c055daaad2" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/minus_.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad2" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderhopen.gif" alt=""><a id="sindexmenu_13723864845322c055daaad2" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/microcontroller" title="PDQ Board" onmouseover="indexmenu_13723864845322c055daaad.show_feat('2');" onmousedown="return indexmenu_checkcontextm('2',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(2);">PDQ Board</a></div><div id="dindexmenu_13723864845322c055daaad2" class="clip" style="display: block;"><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad3" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad3" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/mc9s12a512-mc9s12dp512-datasheets/microcontroller" title="Freescale HCS12 9S12 Datasheets" onmouseover="indexmenu_13723864845322c055daaad.show_feat('3');" onmousedown="return indexmenu_checkcontextm('3',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(3);">Freescale HCS12 9S12 Datasheets</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><a href="javascript:%20indexmenu_13723864845322c055daaad.o(4);"><img id="jindexmenu_13723864845322c055daaad4" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/minus_.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad4" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderhopen.gif" alt=""><a id="sindexmenu_13723864845322c055daaad4" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller" title="PDQ Board Users Guide" onmouseover="indexmenu_13723864845322c055daaad.show_feat('4');" onmousedown="return indexmenu_checkcontextm('4',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(4);">PDQ Board Users Guide</a></div><div id="dindexmenu_13723864845322c055daaad4" class="clip" style="display: block;"><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad5" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad5" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-projects" title="Overview of Hardware and Software" onmouseover="indexmenu_13723864845322c055daaad.show_feat('5');" onmousedown="return indexmenu_checkcontextm('5',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(5);">Overview of Hardware and Software</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad6" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad6" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-design" title="Getting to Know Your Hardware" onmouseover="indexmenu_13723864845322c055daaad.show_feat('6');" onmousedown="return indexmenu_checkcontextm('6',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(6);">Getting to Know Your Hardware</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad7" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad7" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/modular-power-supply" title="Using Your Docking Panel" onmouseover="indexmenu_13723864845322c055daaad.show_feat('7');" onmousedown="return indexmenu_checkcontextm('7',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(7);">Using Your Docking Panel</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad8" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad8" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/gnu-c-compiler-ide" title="Installing and Connecting to PDQ Board" onmouseover="indexmenu_13723864845322c055daaad.show_feat('8');" onmousedown="return indexmenu_checkcontextm('8',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(8);">Installing and Connecting to PDQ Board</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad9" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad9" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-application-programming" title="Your First C Program Using Mosaic IDE Plus" onmouseover="indexmenu_13723864845322c055daaad.show_feat('9');" onmousedown="return indexmenu_checkcontextm('9',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(9);">Your First C Program Using Mosaic IDE Plus</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad10" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad10" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-compiler-programming" title="Writing and Compiling Programs" onmouseover="indexmenu_13723864845322c055daaad.show_feat('10');" onmousedown="return indexmenu_checkcontextm('10',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(10);">Writing and Compiling Programs</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad11" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad11" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-compile-edit-debug" title="Mosaic IDE Plus" onmouseover="indexmenu_13723864845322c055daaad.show_feat('11');" onmousedown="return indexmenu_checkcontextm('11',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(11);">Mosaic IDE Plus</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad12" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad12" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/c-debugger" title="Debugging Programs" onmouseover="indexmenu_13723864845322c055daaad.show_feat('12');" onmousedown="return indexmenu_checkcontextm('12',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(12);">Debugging Programs</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad13" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad13" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-memory-map-eeprom-flash-ram" title="Using Paged Memory" onmouseover="indexmenu_13723864845322c055daaad.show_feat('13');" onmousedown="return indexmenu_checkcontextm('13',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(13);">Using Paged Memory</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad14" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad14" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/real-time-operating-system-rtos" title="Task Switching and Time Keeping" onmouseover="indexmenu_13723864845322c055daaad.show_feat('14');" onmousedown="return indexmenu_checkcontextm('14',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(14);">Task Switching and Time Keeping</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad15" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad15" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/isr-interrupt-service-routines" title="Interrupt Service Routines" onmouseover="indexmenu_13723864845322c055daaad.show_feat('15');" onmousedown="return indexmenu_checkcontextm('15',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(15);">Interrupt Service Routines</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad16" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad16" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-autostart-application" title="Loading Your Program into Memory" onmouseover="indexmenu_13723864845322c055daaad.show_feat('16');" onmousedown="return indexmenu_checkcontextm('16',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(16);">Loading Your Program into Memory</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad17" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad17" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/paged-ram-flash-nonvolatile" title="Storing and Accessing Data in Paged RAM and Flash" onmouseover="indexmenu_13723864845322c055daaad.show_feat('17');" onmousedown="return indexmenu_checkcontextm('17',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(17);">Storing and Accessing Data in Paged RAM and Flash</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad18" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad18" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/eeprom-lifetime-reliability-wear-leveling" title="EEPROM Reliability and Wear Leveling" onmouseover="indexmenu_13723864845322c055daaad.show_feat('18');" onmousedown="return indexmenu_checkcontextm('18',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(18);">EEPROM Reliability and Wear Leveling</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad19" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad19" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/watchdog-timer-reset" title="Failure and Run-Time Error Recovery" onmouseover="indexmenu_13723864845322c055daaad.show_feat('19');" onmousedown="return indexmenu_checkcontextm('19',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(19);">Failure and Run-Time Error Recovery</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad20" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad20" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/digital-i-o" title="Digital I/O - Reading and Writing" onmouseover="indexmenu_13723864845322c055daaad.show_feat('20');" onmousedown="return indexmenu_checkcontextm('20',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(20);">Digital I/O - Reading and Writing</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad21" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad21" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/interfacing-hardware-digital-io" title="Digital I/O - Hardware Interfacing" onmouseover="indexmenu_13723864845322c055daaad.show_feat('21');" onmousedown="return indexmenu_checkcontextm('21',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(21);">Digital I/O - Hardware Interfacing</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad22" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad22" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/pulse-width-modulation-pwm-motor-control" title="Pulse Width Modulated I/O" onmouseover="indexmenu_13723864845322c055daaad.show_feat('22');" onmousedown="return indexmenu_checkcontextm('22',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(22);">Pulse Width Modulated I/O</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad23" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad23" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-input-capture-output-compare-pwm-pulse-counter-frequency-meter" title="Timer-Controlled I/O" onmouseover="indexmenu_13723864845322c055daaad.show_feat('23');" onmousedown="return indexmenu_checkcontextm('23',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(23);">Timer-Controlled I/O</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad24" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad24" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/analog-data-acquisition-10-bit-adc" title="Data Acquisition Using Analog to Digital Conversion" onmouseover="indexmenu_13723864845322c055daaad.show_feat('24');" onmousedown="return indexmenu_checkcontextm('24',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(24);">Data Acquisition Using Analog to Digital Conversion</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad25" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad25" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/rs232-serial-rs485-protocol-uart-usart" title="Serial Communications" onmouseover="indexmenu_13723864845322c055daaad.show_feat('25');" onmousedown="return indexmenu_checkcontextm('25',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(25);">Serial Communications</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad26" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad26" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/rs232-serial-rs485-protocol-uart-usart-buffered" title="Using Queued Serial" onmouseover="indexmenu_13723864845322c055daaad.show_feat('26');" onmousedown="return indexmenu_checkcontextm('26',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(26);">Using Queued Serial</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad27" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad27" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/software-uart-serial" title="Implementing Logic-Level Serial Ports" onmouseover="indexmenu_13723864845322c055daaad.show_feat('27');" onmousedown="return indexmenu_checkcontextm('27',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(27);">Implementing Logic-Level Serial Ports</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad28" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad28" class="navSel" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/spi-serial-peripheral-interface" title="Serial Peripheral Interface (SPI)" onmouseover="indexmenu_13723864845322c055daaad.show_feat('28');" onmousedown="return indexmenu_checkcontextm('28',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(28);">Serial Peripheral Interface (SPI)</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad29" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad29" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-i2c-bus" title="Inter-IC (IIC, I²C, I2C) Serial Bus" onmouseover="indexmenu_13723864845322c055daaad.show_feat('29');" onmousedown="return indexmenu_checkcontextm('29',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(29);">Inter-IC (IIC, I²C, I2C) Serial Bus</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad30" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad30" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/i2c-bus-specifications" title="I2C Bus Electrical Specifications" onmouseover="indexmenu_13723864845322c055daaad.show_feat('30');" onmousedown="return indexmenu_checkcontextm('30',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(30);">I2C Bus Electrical Specifications</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad31" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad31" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-rtc-real-time-clock-battery" title="Using Battery-Backed Calendar Time Clock" onmouseover="indexmenu_13723864845322c055daaad.show_feat('31');" onmousedown="return indexmenu_checkcontextm('31',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(31);">Using Battery-Backed Calendar Time Clock</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad32" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad32" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-c-coding-c-example-program" title="A Turnkeyed C Application Program" onmouseover="indexmenu_13723864845322c055daaad.show_feat('32');" onmousedown="return indexmenu_checkcontextm('32',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(32);">A Turnkeyed C Application Program</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad33" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad33" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-forth-language" title="A Brief Introduction to Forth Programming" onmouseover="indexmenu_13723864845322c055daaad.show_feat('33');" onmousedown="return indexmenu_checkcontextm('33',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(33);">A Brief Introduction to Forth Programming</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad34" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad34" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/forth-language-program-development" title="Advanced Forth Programming Topics" onmouseover="indexmenu_13723864845322c055daaad.show_feat('34');" onmousedown="return indexmenu_checkcontextm('34',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(34);">Advanced Forth Programming Topics</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad35" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad35" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/forth-real-time-operating-system" title="Multitasking in Forth" onmouseover="indexmenu_13723864845322c055daaad.show_feat('35');" onmousedown="return indexmenu_checkcontextm('35',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(35);">Multitasking in Forth</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad36" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad36" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-forth-language-forth-example-program" title="A Turnkeyed Forth Application Program" onmouseover="indexmenu_13723864845322c055daaad.show_feat('36');" onmousedown="return indexmenu_checkcontextm('36',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(36);">A Turnkeyed Forth Application Program</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad37" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad37" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/paged-memory-code-relocation" title="For Experts: Compilation and Segment Management" onmouseover="indexmenu_13723864845322c055daaad.show_feat('37');" onmousedown="return indexmenu_checkcontextm('37',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(37);">For Experts: Compilation and Segment Management</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad38" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad38" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-specifications" title="Appendix A: PDQ Board (9S12 HCS12) Electrical Specifications" onmouseover="indexmenu_13723864845322c055daaad.show_feat('38');" onmousedown="return indexmenu_checkcontextm('38',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(38);">Appendix A: PDQ Board (9S12 HCS12) Electrical Specifications</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad39" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad39" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/input-output-connectors" title="Appendix B: Connector Pinouts" onmouseover="indexmenu_13723864845322c055daaad.show_feat('39');" onmousedown="return indexmenu_checkcontextm('39',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(39);">Appendix B: Connector Pinouts</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad40" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad40" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/microcontroller-schematics" title="Appendix C: Schematics" onmouseover="indexmenu_13723864845322c055daaad.show_feat('40');" onmousedown="return indexmenu_checkcontextm('40',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(40);">Appendix C: Schematics</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad41" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad41" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/programming-tips" title="Checklist" onmouseover="indexmenu_13723864845322c055daaad.show_feat('41');" onmousedown="return indexmenu_checkcontextm('41',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(41);">Checklist</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad42" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad42" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/compiler-error-messages" title="Error Messages" onmouseover="indexmenu_13723864845322c055daaad.show_feat('42');" onmousedown="return indexmenu_checkcontextm('42',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(42);">Error Messages</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/joinbottom.gif" alt=""><img id="iindexmenu_13723864845322c055daaad43" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad43" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/instrument-control/faq" title="FAQ, Frequently Asked Questions" onmouseover="indexmenu_13723864845322c055daaad.show_feat('43');" onmousedown="return indexmenu_checkcontextm('43',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(43);">FAQ, Frequently Asked Questions</a></div></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad44" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad44" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/hcs12-9s12-an-introduction-to-software-and-hardware-interfacing" title="PDQ Board Overview" onmouseover="indexmenu_13723864845322c055daaad.show_feat('44');" onmousedown="return indexmenu_checkcontextm('44',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(44);">PDQ Board Overview</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad45" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad45" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/measurement-control-i-o-cards" title="Compatible Accessories" onmouseover="indexmenu_13723864845322c055daaad.show_feat('45');" onmousedown="return indexmenu_checkcontextm('45',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(45);">Compatible Accessories</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/joinbottom.gif" alt=""><img id="iindexmenu_13723864845322c055daaad46" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/page.gif" alt=""><a id="sindexmenu_13723864845322c055daaad46" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/freescale-hcs12-9s12-c-language/mc9s12dp512-microcontroller-schematic" title="The MC9S12A512 Processor" onmouseover="indexmenu_13723864845322c055daaad.show_feat('46');" onmousedown="return indexmenu_checkcontextm('46',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(46);">The MC9S12A512 Processor</a></div></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><a href="javascript:%20indexmenu_13723864845322c055daaad.o(47);"><img id="jindexmenu_13723864845322c055daaad47" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus_.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad47" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad47" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/hcs12-9s12-freescale-development-board/microcontroller" title="PDQ Board Lite" onmouseover="indexmenu_13723864845322c055daaad.show_feat('47');" onmousedown="return indexmenu_checkcontextm('47',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(47);">PDQ Board Lite</a></div><div id="dindexmenu_13723864845322c055daaad47" class="clip" style="display:none;"></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/line.gif" alt=""><a href="javascript:%20indexmenu_13723864845322c055daaad.o(53);"><img id="jindexmenu_13723864845322c055daaad53" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus_bottom.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad53" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad53" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers/68hc11-c-language/microcontroller" title="QCard Controller" onmouseover="indexmenu_13723864845322c055daaad.show_feat('53');" onmousedown="return indexmenu_checkcontextm('53',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(53);">QCard Controller</a></div><div id="dindexmenu_13723864845322c055daaad53" class="clip" style="display:none;"></div></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(78);"><img id="jindexmenu_13723864845322c055daaad78" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad78" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad78" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/gui-user-interface/microcontroller" title="GUI/Touchscreen Controllers" onmouseover="indexmenu_13723864845322c055daaad.show_feat('78');" onmousedown="return indexmenu_checkcontextm('78',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(78);">GUI/Touchscreen Controllers</a></div><div id="dindexmenu_13723864845322c055daaad78" class="clip" style="display:none;"></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad138" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad138" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/sbc-single-board-computers-instrument-development-kits-new-product-design/microcontroller" title="Starter Kits" onmouseover="indexmenu_13723864845322c055daaad.show_feat('138');" onmousedown="return indexmenu_checkcontextm('138',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(138);">Starter Kits</a></div><div class="dTreeNode"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/join.gif" alt=""><img id="iindexmenu_13723864845322c055daaad139" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad139" class="nodeUrl" href="http://www.mosaic-industries.com/embedded-systems/modular-power-io-panels/microcontroller" title="Docking Panels" onmouseover="indexmenu_13723864845322c055daaad.show_feat('139');" onmousedown="return indexmenu_checkcontextm('139',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(139);">Docking Panels</a></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(140);"><img id="jindexmenu_13723864845322c055daaad140" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad140" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad140" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/instrumentation/microcontroller" title="Modular I/O Boards" onmouseover="indexmenu_13723864845322c055daaad.show_feat('140');" onmousedown="return indexmenu_checkcontextm('140',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(140);">Modular I/O Boards</a></div><div id="dindexmenu_13723864845322c055daaad140" class="clip" style="display:none;"></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(276);"><img id="jindexmenu_13723864845322c055daaad276" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad276" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad276" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/electronic-instrument-design-new-product-development/microcontroller" title="Accessories" onmouseover="indexmenu_13723864845322c055daaad.show_feat('276');" onmousedown="return indexmenu_checkcontextm('276',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(276);">Accessories</a></div><div id="dindexmenu_13723864845322c055daaad276" class="clip" style="display:none;"></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(289);"><img id="jindexmenu_13723864845322c055daaad289" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad289" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad289" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/c-ide-software-development/microcontroller" title="Development Software" onmouseover="indexmenu_13723864845322c055daaad.show_feat('289');" onmousedown="return indexmenu_checkcontextm('289',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(289);">Development Software</a></div><div id="dindexmenu_13723864845322c055daaad289" class="clip" style="display:none;"></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(354);"><img id="jindexmenu_13723864845322c055daaad354" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plus.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad354" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad354" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/c-tutorial/microcontroller" title="Software Examples" onmouseover="indexmenu_13723864845322c055daaad.show_feat('354');" onmousedown="return indexmenu_checkcontextm('354',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(354);">Software Examples</a></div><div id="dindexmenu_13723864845322c055daaad354" class="clip" style="display:none;"></div><div class="dTreeNode"><a href="javascript:%20indexmenu_13723864845322c055daaad.o(357);"><img id="jindexmenu_13723864845322c055daaad357" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/plusbottom.gif" alt=""></a><img id="iindexmenu_13723864845322c055daaad357" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/folderh.gif" alt=""><a id="sindexmenu_13723864845322c055daaad357" class="nodeFdUrl" href="http://www.mosaic-industries.com/embedded-systems/microcontroller-projects/microcontroller" title="App Notes &amp; Toolkits" onmouseover="indexmenu_13723864845322c055daaad.show_feat('357');" onmousedown="return indexmenu_checkcontextm('357',indexmenu_13723864845322c055daaad,event);" oncontextmenu="return indexmenu_stopevt(event)" onclick="javascript: indexmenu_13723864845322c055daaad.s(357);">App Notes &amp; Toolkits</a></div><div id="dindexmenu_13723864845322c055daaad357" class="clip" style="display:none;"></div></div></div><div id="zindexmenu_13723864845322c055daaad" class="indexmenu_rarrow"></div><div id="left_indexmenu_13723864845322c055daaad" class="indexmenu_larrow" style="display:none;" title="Click to scroll back" onmousedown="javascript:indexmenu_13723864845322c055daaad.scroll('r',1);" onmouseup="javascript:indexmenu_13723864845322c055daaad.stopscroll();"></div></div></td></tr></tbody></table>
<div class="block" style="margin-bottom:0;position:relative;top:-.4em;padding-left:20px;width:100%;padding-top:5px;padding-bottom:0"><span class="inline action16 imglink help"><strong><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="wikilink1" title="dokuwiki:help-for-readers:microcontroller" rel="nofollow">Help</a></strong></span>
</div>
<a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>
<!-- EDIT1 SECTION "Navigation" [284-] --></nav></div></div><div class="sbar rounded tinted __tpl_quicklinks" style="margin-top:.35em;"><div class="tglclose" title="Hide" onclick="toggleVisibility(this)"><div>&nbsp;</div>Quick Links</div><div style="display:block"><nav class="sb">

<div class="level1">
<div class="block local"><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" class="action16 book" title="Your local Documentation Web home page" rel="nofollow">Documentation home page</a>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_discussion" class="action16 comments" target="_blank" title="We'll respond ASAP to your questions about programming our embedded controllers" rel="nofollow">Ask questions/comment</a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_faqs" class="action16 question" title="Learn the answers to frequently asked questions" rel="nofollow">Frequently asked questions</a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_discussion" class="action16 bug" target="_blank" title="Please report any bugs you find" rel="nofollow">Report bugs </a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="action16 inform" title="How to navigate and find things" rel="nofollow">Using this Doc Web</a>
</p>
<p><a href="http://www.mosaic-industries.com/" class="action16 mosaic" target="_blank" title="Find controllers for instrumentation and automation at the Mosaic Industries site" rel="nofollow">Mosaic Industries web site</a>
</p>
<p><a href="http://www.mosaic-industries.com/About" class="action16 users" target="_blank" title="About Mosaic Industries, manufacturers of embedded computers and I/O devices" rel="nofollow">About Mosaic Industries</a>
</p>
<p><span class="curid"><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/contact-us" class="action16 phone" title="Help is just a phone call away" rel="nofollow">Contact us</a></span>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="action16 help" title="Search the help pages" rel="nofollow">Help!</a>
</p></div>
<div class="block public"><a href="http://www.mosaic-industries.com/embedded-systems/microcontroller" class="action16 book" title="Documentation Web home page" rel="nofollow">Documentation home page</a>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_discussion" class="action16 comments" title="We'll respond ASAP to your questions about programming our embedded controllers" rel="nofollow">Ask questions/comment</a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_faqs" class="action16 question" title="Learn the answers to frequently asked questions" rel="nofollow">Frequently asked questions</a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/tpl_discussion" class="action16 bug" title="Please report any bugs you find" rel="nofollow">Report bugs</a>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="action16 inform" title="How to navigate and find things" rel="nofollow">Using this Doc Web</a>
</p>
<p><a href="http://www.mosaic-industries.com/" class="action16 mosaic" target="_blank" title="Find controllers for instrumentation and automation at the Mosaic Industries site" rel="nofollow">Mosaic Industries web site</a>
</p>
<p><a href="http://www.mosaic-industries.com/About" class="action16 users" target="_blank" title="About Mosaic Industries, manufacturers of embedded computers and I/O devices" rel="nofollow">About Mosaic Industries</a>
</p>
<p><span class="curid"><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/contact-us" class="action16 phone" title="Help is just a phone call away" rel="nofollow">Contact us</a></span>
</p>
<p><a href="http://www.mosaic-industries.com/embedded-systems/dokuwiki/help-for-readers/microcontroller" class="action16 help" title="Search the help pages" rel="nofollow">Help!</a>
</p></div>
<a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>
<!-- EDIT1 SECTION "Quick Links" [468-] --></nav></div></div><div class="sbar rounded tinted __tpl_tagcloud" style="margin-top:.35em;"><div class="tglclose" title="Hide" onclick="toggleVisibility(this)"><div>&nbsp;</div>Tags</div><div style="display:block"><nav class="sb">

<div class="level1"><div class="cloud">
<a href="http://www.mosaic-industries.com/embedded-systems/tag/analog?do=showtag&amp;tag=analog" class="cloud5_tag2" title="analog" rel="nofollow">analog</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/automation?do=showtag&amp;tag=automation" class="cloud3_tag2" title="automation" rel="nofollow">automation</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/c-examples?do=showtag&amp;tag=c-examples" class="cloud5_tag2" title="c-examples" rel="nofollow">c-examples</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/data-acquisition?do=showtag&amp;tag=data-acquisition" class="cloud5_tag2" title="data-acquisition" rel="nofollow">data-acquisition</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/data-display?do=showtag&amp;tag=data-display" class="cloud3_tag2" title="data-display" rel="nofollow">data-display</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/data-entry?do=showtag&amp;tag=data-entry" class="cloud3_tag2" title="data-entry" rel="nofollow">data-entry</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/data-storage?do=showtag&amp;tag=data-storage" class="cloud1_tag2" title="data-storage" rel="nofollow">data-storage</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/digital?do=showtag&amp;tag=digital" class="cloud5_tag2" title="digital" rel="nofollow">digital</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/forth-examples?do=showtag&amp;tag=forth-examples" class="cloud5_tag2" title="forth-examples" rel="nofollow">forth-examples</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/hmi?do=showtag&amp;tag=hmi" class="cloud1_tag2" title="hmi" rel="nofollow">hmi</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/industrial-communications?do=showtag&amp;tag=industrial-communications" class="cloud3_tag2" title="industrial-communications" rel="nofollow">industrial-communications</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/internet-cloud?do=showtag&amp;tag=internet-cloud" class="cloud2_tag2" title="internet-cloud" rel="nofollow">internet-cloud</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/motor-control?do=showtag&amp;tag=motor-control" class="cloud5_tag2" title="motor-control" rel="nofollow">motor-control</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/panel-display?do=showtag&amp;tag=panel-display" class="cloud1_tag2" title="panel-display" rel="nofollow">panel-display</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/pc-interface?do=showtag&amp;tag=pc-interface" class="cloud5_tag2" title="pc-interface" rel="nofollow">pc-interface</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/pid-control?do=showtag&amp;tag=pid-control" class="cloud4_tag2" title="pid-control" rel="nofollow">pid-control</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/prototyping?do=showtag&amp;tag=prototyping" class="cloud3_tag2" title="prototyping" rel="nofollow">prototyping</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/pwm?do=showtag&amp;tag=pwm" class="cloud3_tag2" title="pwm" rel="nofollow">pwm</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/remote-device?do=showtag&amp;tag=remote-device" class="cloud4_tag2" title="remote-device" rel="nofollow">remote-device</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/remote-email?do=showtag&amp;tag=remote-email" class="cloud1_tag2" title="remote-email" rel="nofollow">remote-email</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/robotics?do=showtag&amp;tag=robotics" class="cloud3_tag2" title="robotics" rel="nofollow">robotics</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/scientific-measurement?do=showtag&amp;tag=scientific-measurement" class="cloud5_tag2" title="scientific-measurement" rel="nofollow">scientific-measurement</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/solenoid-control?do=showtag&amp;tag=solenoid-control" class="cloud5_tag2" title="solenoid-control" rel="nofollow">solenoid-control</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/temperature?do=showtag&amp;tag=temperature" class="cloud5_tag2" title="temperature" rel="nofollow">temperature</a>
<a href="http://www.mosaic-industries.com/embedded-systems/tag/web-remote-control?do=showtag&amp;tag=web-remote-control" class="cloud2_tag2" title="web-remote-control" rel="nofollow">web-remote-control</a>
</div>
<a class="backtotop" href="#dokuwiki__top" rel="nofollow" onclick="window.scrollTo(0, 0)" title="Back to top">&nbsp;</a></div>
<!-- EDIT1 SECTION "Tags" [283-] --></nav></div></div></div>
</div>
<script type="text/javascript">xGetElementById('left__col').style['width']='224px';xGetElementById('center__content').style['marginLeft']='224px';xGetElementById('left__col').style.display='block';xGetElementById('body__width').className='wleft';</script>
<div class="clearer">&nbsp;</div>
<footer>
<div class="__tpl_bottom">
<div class="box center" style="width:auto; background-color: rgb(248,248,248); border-color: rgb(207,207,239);">
  <b class="xtop"><b class="xb1" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb2" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb3" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb4" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b></b>
  <div class="xbox" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);">
<div class="box_content" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239)">
<div class="block centeralign">
<a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/user-agreement" class="wikilink1" title="User Agreement" rel="nofollow">User Agreement</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/privacy" class="wikilink1" title="Privacy Policy" rel="nofollow">Privacy Policy</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/eula" class="wikilink1" title="End User License Agreement" rel="nofollow">End User License Agreement</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/salesterms" class="wikilink1" title="Sales Terms and Conditions" rel="nofollow">Sales Terms and Conditions</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/lifesupport" class="wikilink1" title="Life Support" rel="nofollow">Life Support Policy</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/trademarks" class="wikilink1" title="Trademarks" rel="nofollow">Trademarks</a> | <a href="http://www.mosaic-industries.com/embedded-systems/hidden_legal/microcontroller" class="wikilink1" title="All Policies" rel="nofollow">All Policies</a>
</div></div>
  </div>
  <b class="xbottom"><b class="xb4" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb3" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb2" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b><b class="xb1" style="background-color: rgb(248,248,248); border-color: rgb(207,207,239);"></b></b>
</div>

</div><div class="bar">
<div class="bar-left">
<a target="_blank" class="btnmosaic" href="http://www.mosaic-industries.com/embedded-systems/wiki/mosaic-template" title="Dokuwiki Mosaic Template, by Mosaic Industries, manufacturer of single board computers and embedded device servers for instruments and automation"></a></div>
<div class="bar-right">
<a target="_blank" class="btndw" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Animated by Doku_Wiki" rel="nofollow"></a></div>
<div class="bar-center"><br>© Mosaic Industries, Inc. All rights reserved.
</div><div class="clearer"></div>
</div>
</footer>
<div id="login__btn"><div id="login__pos"><div id="m__clk">Fri, Mar 14, 6:34 pm</div></div></div>
<div id="search__pos"><form action="/embedded-systems/" accept-charset="utf-8" class="search" id="dw__search" method="get"><div class="no"><input name="do" value="search" type="hidden"><input id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" type="text"><input value="Search" class="button" title="Search" type="submit"><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form></div>
</div>
<div class="no"><img src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/indexer.gif" alt="" width="2" height="1"></div>
</div></div>
<script type="text/javascript">initMosaic();</script><script type="text/javascript">(function(){var po=document.createElement('script');po.type='text/javascript'; po.async = true;po.src='https://apis.google.com/js/plusone.js';var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(po, s);})();</script>


<div style="position: absolute; display: none;" id="rindexmenu_13723864845322c055daaad" class="indexmenu_rmenu default"></div><iframe tabindex="-1" style="width: 1px; height: 1px; position: absolute; top: -100px;" src="Using%20Serial%20Peripheral%20Interface%20%28SPI%29%20for%20Fast%20Serial%20Data%20Exchange_files/postmessageRelay.html" id="oauth2relay46870287" name="oauth2relay46870287"></iframe></body><iframe src="" style="display: none;"></iframe></html>