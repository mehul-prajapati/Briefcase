<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><title>Boot process, Init and shutdown</title><meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.7"><link rel="HOME" title="Introduction to Linux" href="http://www.tldp.org/LDP/intro-linux/html/index.html"><link rel="UP" title="Processes" href="http://www.tldp.org/LDP/intro-linux/html/chap_04.html"><link rel="PREVIOUS" title="Processes inside out" href="http://www.tldp.org/LDP/intro-linux/html/sect_04_01.html"><link rel="NEXT" title="Managing processes" href="http://www.tldp.org/LDP/intro-linux/html/sect_04_03.html"></head><body class="sect1" text="#000000" vlink="#840084" link="#0000FF" alink="#0000FF" bgcolor="#FFFFFF"><div class="NAVHEADER"><table summary="Header navigation table" width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><th colspan="3" align="center">Introduction to Linux: </th></tr><tr><td valign="bottom" width="10%" align="left"><a href="http://www.tldp.org/LDP/intro-linux/html/sect_04_01.html" accesskey="P">Prev</a></td><td valign="bottom" width="80%" align="center">Chapter 4. Processes</td><td valign="bottom" width="10%" align="right"><a href="http://www.tldp.org/LDP/intro-linux/html/sect_04_03.html" accesskey="N">Next</a></td></tr></tbody></table><hr width="100%" align="LEFT"></div><div class="sect1"><h1 class="sect1"><a name="sect_04_02"></a>4.2. Boot process, Init and shutdown</h1><div class="sect2"><h2 class="sect2"><a name="sect_04_02_01"></a>4.2.1. Introduction</h2><p>
 One of the most powerful aspects of Linux concerns its open method of 
starting and stopping the operating system, where it loads specified 
programs using their particular configurations, permits you to change 
those configurations to control the boot process, and shuts down in a 
graceful and organized way.</p><p> Beyond the question of controlling 
the boot or shutdown process, the open nature of Linux makes it much 
easier to determine the exact source of most problems associated with 
starting up or shutting down your system. A basic understanding of this 
process is quite beneficial to everybody who uses a Linux system.</p><p>A lot of Linux systems use <b class="command">lilo</b>, the <span class="application">LInux LOader</span>
 for booting operating systems.  We will only discuss GRUB, however, 
which is easier to use and more flexible.  Should you need information 
about <b class="command">lilo</b>, refer to the man pages and HOWTOs.  
Both systems support dual boot installations, we refer to the HOWTOs on 
this subject for practical examples and background information.</p></div><div class="sect2"><h2 class="sect2"><a name="sect_04_02_02"></a>4.2.2. The boot process</h2><p>When
 an x86 computer is booted, the processor looks at the end of the system
 memory for the BIOS (Basic Input/Output System) and runs it. The BIOS 
program is written into permanent read-only memory and is always 
available for use. The BIOS provides the lowest level interface to 
peripheral devices and controls the first step of the boot process.</p><p>
 The BIOS tests the system, looks for and checks peripherals, and then 
looks for a drive to use to boot the system. Usually it checks the 
floppy drive (or CD-ROM drive on many newer systems) for bootable media,
 if present, and then it looks to the hard drive. The order of the 
drives used for booting is usually controlled by a particular BIOS 
setting on the system.  Once Linux is installed on the hard drive of a 
system, the BIOS looks for a Master Boot Record (MBR) starting at the 
first sector on the first hard drive, loads its contents into memory, 
then passes control to it.</p><p> This MBR contains instructions on how 
to load the GRUB (or LILO) boot-loader, using a pre-selected operating 
system.  The MBR then loads the boot-loader, which takes over the 
process (if the boot-loader is installed in the MBR). In the default Red
 Hat Linux configuration, GRUB uses the settings in the MBR to display 
boot options in a menu.  Once GRUB has received the correct instructions
 for the operating system to start, either from its command line or 
configuration file, it finds the necessary boot file and hands off 
control of the machine to that operating system.</p></div><div class="sect2"><h2 class="sect2"><a name="sect_04_02_03"></a>4.2.3. GRUB features</h2><p>This boot method is called <em>direct loading</em>
 because instructions are used to directly load the operating system, 
with no intermediary code between the boot-loaders and the operating 
system's main files (such as the kernel). The boot process used by other
 operating systems may differ slightly from the above, however. For 
example, Microsoft's DOS and Windows operating systems completely 
overwrite anything on the MBR when they are installed without 
incorporating any of the current MBR's configuration. This destroys any 
other information stored in the MBR by other operating systems, such as 
Linux. The Microsoft operating systems, as well as various other 
proprietary operating systems, are loaded using a chain loading boot 
method. With this method, the MBR points to the first sector of the 
partition holding the operating system, where it finds the special files
 necessary to actually boot that operating system.</p><p>GRUB supports 
both boot methods, allowing you to use it with almost any operating 
system, most popular file systems, and almost any hard disk your BIOS 
can recognize.</p><p>GRUB contains a number of other features; the most important include:</p><p></p><ul><li><p>GRUB
 provides a true command-based, pre-OS environment on x86 machines to 
allow maximum flexibility in loading operating systems with certain 
options or gathering information about the system.</p></li><li><p>GRUB 
supports Logical Block Addressing (LBA) mode, needed to access many IDE 
and all SCSI hard disks.  Before LBA, hard drives could encounter a 
1024-cylinder limit, where the BIOS could not find a file after that 
point.</p></li><li><p>GRUB's configuration file is read from the disk 
every time the system boots, preventing you from having to write over 
the MBR every time you change the boot options.</p></li></ul><p>A full description of GRUB may be found by issuing the <b class="command">info <tt class="parameter"><i>grub</i></tt></b> command or at <a href="http://www.gnu.org/software/grub/" target="_top">the GRUB site</a>.  The Linux Documentation Project has a <a href="http://www.tldp.org/HOWTO/mini/Multiboot-with-GRUB.html" target="_top">Multiboot with GRUB Mini-HOWTO</a>.</p></div><div class="sect2"><h2 class="sect2"><a name="sect_04_02_04"></a>4.2.4. Init</h2><p>The kernel, once it is loaded, finds <b class="command">init</b> in <tt class="filename">sbin</tt> and executes it.</p><p>When <b class="command">init</b>
 starts, it becomes the parent or grandparent of all of the processes 
that start up automatically on your Linux system. The first thing <b class="command">init</b> does, is reading its initialization file, <tt class="filename">/etc/inittab</tt>.  This instructs <b class="command">init</b>
 to read an initial configuration script for the environment, which sets
 the path, starts swapping, checks the file systems, and so on. 
Basically, this step takes care of everything that your system needs to 
have done at system initialization: setting the clock, initializing 
serial ports and so forth.</p><p> Then <b class="command">init</b> continues to read the <tt class="filename">/etc/inittab</tt> file, which describes how the system should be set up in each run level and sets the default <em>run level</em>.
  A run level is a configuration of processes.  All UNIX-like systems 
can be run in different process configurations, such as the single user 
mode, which is referred to as run level 1 or run level S (or s).  In 
this mode, only the system administrator can connect to the system.  It 
is used to perform maintenance tasks without risks of damaging the 
system or user data.  Naturally, in this configuration we don't need to 
offer user services, so they will all be disabled.  Another run level is
 the reboot run level, or run level 6, which shuts down all running 
services according to the appropriate procedures and then restarts the 
system.</p><p>Use the <b class="command">who</b> to check what your current run level is:</p><table width="100%" bgcolor="#E0E0E0" border="0"><tbody><tr><td><font color="#000000"><pre class="screen"><tt class="prompt">willy@ubuntu:~$ </tt><b class="command">who <tt class="option">-r</tt></b>
	run-level 2 2006-10-17 23:22		last=S
</pre></font></td></tr></tbody></table><p>More about run levels in the next section, see <a href="http://www.tldp.org/LDP/intro-linux/html/sect_04_02.html#sect_04_02_05">Section 4.2.5</a>.</p><p>After having determined the default run level for your system, <b class="command">init</b> starts all of the background processes necessary for the system to run by looking in the appropriate <tt class="filename">rc</tt> directory for that run level.  <b class="command">init</b>
 runs each of the kill scripts (their file names start with a K) with a 
stop parameter.  It then runs all of the start scripts (their file names
 start with an S) in the appropriate run level directory so that all 
services and applications are started correctly. In fact, you can 
execute these same scripts manually after the system is finished booting
 with a command like <b class="command">/etc/init.d/httpd <tt class="parameter"><i>stop</i></tt></b> or <b class="command">service <tt class="parameter"><i>httpd</i></tt> <tt class="parameter"><i>stop</i></tt></b> logged in as <em>root</em>, in this case stopping the web server.</p><div class="note"><p></p><table class="note" width="100%" border="0"><tbody><tr><td valign="TOP" width="25" align="CENTER"><img src="Boot%20process,%20Init%20and%20shutdown_files/note.gif" alt="Note" hspace="5"></td><th valign="CENTER" align="LEFT"><b>Special case</b></th></tr><tr><td>&nbsp;</td><td valign="TOP" align="LEFT"><p>Note that on system startup, the scripts in <tt class="filename">rc2.d</tt> and <tt class="filename">rc3.d</tt>
 are usually executed.  In that case, no services are stopped (at least 
not permanently).  There are only services that are started.</p></td></tr></tbody></table></div><p> None of the scripts that actually start and stop the services are located in <tt class="filename">/etc/rc&lt;x&gt;.d</tt>. Rather, all of the files in <tt class="filename">/etc/rc&lt;x&gt;.d</tt> are symbolic links that point to the actual scripts located in <tt class="filename">/etc/init.d</tt>.
 A symbolic link is nothing more than a file that points to another 
file, and is used in this case because it can be created and deleted 
without affecting the actual scripts that kill or start the services. 
The symbolic links to the various scripts are numbered in a particular 
order so that they start in that order. You can change the order in 
which the services start up or are killed by changing the name of the 
symbolic link that refers to the script that actually controls the 
service.  You can use the same number multiple times if you want a 
particular service started or stopped right before or after another 
service, as in the example below, listing the content of <tt class="filename">/etc/rc5.d</tt>, where <b class="command">crond</b> and <b class="command">xfs</b> are both started from a linkname starting with <span class="QUOTE">"S90"</span>.  In this case, the scripts are started in alphabetical order.</p><table width="100%" bgcolor="#E0E0E0" border="0"><tbody><tr><td><font color="#000000"><pre class="screen"><tt class="prompt">[jean@blub /etc/rc5.d]</tt> <b class="command">ls</b>
K15httpd@     K45named@    S08ipchains@  S25netfs@      S85gpm@
K16rarpd@     K46radvd@    S08iptables@  S26apmd@       S90crond@
K20nfs@       K61ldap@     S09isdn@      S28autofs@     S90xfs@
K20rstatd@    K65identd@   S10network@   S30nscd@       S95anacron@
K20rusersd@   K74ntpd@     S12syslog@    S55sshd@       S95atd@
K20rwalld@    K74ypserv@   S13portmap@   S56rawdevices@ S97rhnsd@
K20rwhod@     K74ypxfrd@   S14nfslock@   S56xinetd@     S99local@
K25squid@     K89bcm5820@  S17keytable@  S60lpd@
K34yppasswdd@  S05kudzu@    S20random@    S80sendmail@
</pre></font></td></tr></tbody></table><p>After <b class="command">init</b> has progressed through the run levels to get to the default run level, the <tt class="filename">/etc/inittab</tt> script forks a <b class="command">getty</b> process for each virtual console (login prompt in text mode).  <b class="command">getty</b>
 opens tty lines, sets their modes, prints the login prompt, gets the 
user's name, and then initiates a login process for that user.  This 
allows users to authenticate themselves to the system and use it.  By 
default, most systems offer 6 virtual consoles, but as you can see from 
the <tt class="filename">inittab</tt> file, this is configurable.</p><p><tt class="filename">/etc/inittab</tt> can also tell <b class="command">init</b> how it should handle a user pressing <b class="keycap">Ctrl</b>+<b class="keycap">Alt</b>+<b class="keycap">Delete</b> at the console. As the system should be properly shut down and restarted rather than immediately power-cycled, <b class="command">init</b> is told to execute the command <b class="command">/sbin/shutdown <tt class="option">-t3 -r</tt> <tt class="parameter"><i>now</i></tt></b>, for instance, when a user hits those keys. In addition, <tt class="filename">/etc/inittab</tt> states what <b class="command">init</b> should do in case of power failures, if your system has a UPS unit attached to it.</p><p>On most RPM-based systems the graphical login screen is started in run level 5, where <tt class="filename">/etc/inittab</tt> runs a script called <tt class="filename">/etc/X11/prefdm</tt>. The <tt class="filename">prefdm</tt> script runs the preferred X display manager, based on the contents of the <tt class="filename">/etc/sysconfig/desktop</tt> directory.  This is typically <b class="command">gdm</b> if you run GNOME or <b class="command">kdm</b> if you run KDE, but they can be mixed, and there's also the <b class="command">xdm</b> that comes with a standard X installation.</p><p>But
 there are other possibilities as well.  On Debian, for instance, there 
is an initscript for each of the display managers, and the content of 
the <tt class="filename">/etc/X11/default-display-manager</tt> is used to determine which one to start.  More about the graphical interface can be read in <a href="http://www.tldp.org/LDP/intro-linux/html/sect_07_03.html">Section 7.3</a>.  Ultimately, your system documentation will explain the details about the higher level aspects of <b class="command">init</b>.</p><p>The <tt class="filename">/etc/default</tt> and/or <tt class="filename">/etc/sysconfig</tt>
 directories contain entries for a range of functions and services, 
these are all read at boot time.  The location of the directory 
containing system defaults might be somewhat different depending on your
 Linux distribution.</p><p>Besides the graphical user environment, a lot
 of other services may be started as well.  But if all goes well, you 
should be looking at a login prompt or login screen when the boot 
process has finished.</p><div class="note"><p></p><table class="note" width="100%" border="0"><tbody><tr><td valign="TOP" width="25" align="CENTER"><img src="Boot%20process,%20Init%20and%20shutdown_files/note.gif" alt="Note" hspace="5"></td><th valign="CENTER" align="LEFT"><b>Other procedures</b></th></tr><tr><td>&nbsp;</td><td valign="TOP" align="LEFT"><p>We explained how SysV <b class="command">init</b>
 works on x86 based machines.  Startup procedures may vary on other 
architectures and distributions.  Other systems may use the BSD-style <b class="command">init</b>, where startup files are not split up into multiple <tt class="filename">/etc/rc&lt;LEVEL&gt;.d</tt> directories.  It might also be possible that your system uses <tt class="filename">/etc/rc.d/init.d</tt> instead of <tt class="filename">/etc/init.d</tt>.</p></td></tr></tbody></table></div></div><div class="sect2"><h2 class="sect2"><a name="sect_04_02_05"></a>4.2.5. Init run levels</h2><p>
 The idea behind operating different services at different run levels 
essentially revolves around the fact that different systems can be used 
in different ways. Some services cannot be used until the system is in a
 particular state, or <em>mode</em>, such as being ready for more than one user or having networking available.</p><p>
There are times in which you may want to operate the system in a lower 
mode.  Examples are fixing disk corruption problems in run level 1 so no
 other users can possibly be on the system, or leaving a server in run 
level 3 without an X session running. In these cases, running services 
that depend upon a higher system mode to function does not make sense 
because they will not work correctly anyway. By already having each 
service assigned to start when its particular run level is reached, you 
ensure an orderly start up process, and you can quickly change the mode 
of the machine without worrying about which services to manually start 
or stop.</p><p>Available run levels are generally described in <tt class="filename">/etc/inittab</tt>, which is partially shown below:</p><table width="100%" bgcolor="#E0E0E0" border="0"><tbody><tr><td><font color="#000000"><pre class="screen">
#
# inittab   This file describes how the INIT process should set up
#           the system in a certain run-level.

# Default run level. The run levels are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS 
#	(The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:5:initdefault:
&lt;--cut--&gt;
</pre></font></td></tr></tbody></table><p> Feel free to configure unused
 run levels (commonly run level 4) as you see fit. Many users configure 
those run levels in a way that makes the most sense for them while 
leaving the standard run levels as they are by default. This allows them
 to quickly move in and out of their custom configuration without 
disturbing the normal set of features at the standard run levels.</p><p> If your machine gets into a state where it will not boot due to a bad <tt class="filename">/etc/inittab</tt> or will not let you log in because you have a corrupted <tt class="filename">/etc/passwd</tt> file (or if you have simply forgotten your password), boot into single-user mode.</p><div class="tip"><p></p><table class="tip" width="100%" border="0"><tbody><tr><td valign="TOP" width="25" align="CENTER"><img src="Boot%20process,%20Init%20and%20shutdown_files/tip.gif" alt="Tip" hspace="5"></td><th valign="CENTER" align="LEFT"><b>No graphics?</b></th></tr><tr><td>&nbsp;</td><td valign="TOP" align="LEFT"><p>When
 you are working in text mode because you didn't get presented a 
graphical login screen on the console of your machine, you can normally 
switch to console 7 or up to have a graphical login.  If this is not the
 case, check the current run level using the command <b class="command">who <tt class="option">-r</tt></b>.  If it is set to something else than the original default from <tt class="filename">/etc/inittab</tt>, chances are that the system does not start up in graphical mode by default.  Contact your system administrator or read <b class="command">man init</b> in that case.  Note that switching run levels is done preferably using the <b class="command">telinit</b> command; switching from a text to a graphical console or vice versa does not involve a run level switch.</p></td></tr></tbody></table></div><p>The
 discussion of run levels, scripts and configurations in this guide 
tries to be as general as possible.  Lots of variations exist.  For 
instance, Gentoo Linux stores scripts in <tt class="filename">/etc/run levels</tt>.
  Other systems might first run through (a) lower run level(s) and 
execute all the scripts in there before arriving at the final run level 
and executing those scripts.  Refer to your system documentation for 
more information.  You might also read through the scripts that are 
refered to in <tt class="filename">/etc/inittab</tt> to get a better comprehension of what happens on your system.</p><div class="sect3"><h3 class="sect3"><a name="sect_04_02_05_01"></a>4.2.5.1. Tools</h3><p>The <b class="command">chkconfig</b> or <b class="command">update-rc.d</b> utilities, when installed on your system, provide a simple command-line tool for maintaining the <tt class="filename">/etc/init.d</tt>
 directory hierarchy. These relieve system administrators from having to
 directly manipulate the numerous symbolic links in the directories 
under <tt class="filename">/etc/rc[x].d</tt>.</p><p>In addition, some systems offer the <b class="command">ntsysv</b> tool, which provides a text-based interface; you may find this easier to use than <b class="command">chkconfig</b>'s command-line interface.  On SuSE Linux, you will find the <b class="command">yast</b> and <b class="command">insserv</b> tools.  For Mandrake easy configuration, you may want to try <span class="application">DrakConf</span>, which allows among other features switching between run levels 3 and 5.  In Mandriva this became the <span class="application">Mandriva Linux Control Center</span>.</p><p>Most distributions provide a graphical user interface for configuring processes, check with your system documentation.</p><p>
All of these utilities must be run as root.  The system administrator 
may also manually create the appropriate links in each run level 
directory in order to start or stop a service in a certain run level.</p></div></div><div class="sect2"><h2 class="sect2"><a name="sect_04_02_06"></a>4.2.6. Shutdown</h2><p>UNIX was not made to be shut down, but if you really must, use the <b class="command">shutdown</b> command.  After completing the shutdown procedure, the <tt class="option">-h</tt> option will halt the system, while <tt class="option">-r</tt> will reboot it.</p><p>The <b class="command">reboot</b> and <b class="command">halt</b> commands are now able to invoke <b class="command">shutdown</b>
 if run when the system is in run levels 1-5, and thus ensure proper 
shutdown of the system,but  it is a bad habit to get into, as not all 
UNIX/Linux versions have this feature.</p><p>If your computer does not 
power itself down, you should not turn off the computer until you see a 
message indicating that the system is halted or finished shutting down, 
in order to give the system the time to unmount all partitions.  Being 
impatient may cause data loss.</p></div></div><div class="NAVFOOTER"><hr width="100%" align="LEFT"><table summary="Footer navigation table" width="100%" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td valign="top" width="33%" align="left"><a href="http://www.tldp.org/LDP/intro-linux/html/sect_04_01.html" accesskey="P">Prev</a></td><td valign="top" width="34%" align="center"><a href="http://www.tldp.org/LDP/intro-linux/html/index.html" accesskey="H">Home</a></td><td valign="top" width="33%" align="right"><a href="http://www.tldp.org/LDP/intro-linux/html/sect_04_03.html" accesskey="N">Next</a></td></tr><tr><td valign="top" width="33%" align="left">Processes inside out</td><td valign="top" width="34%" align="center"><a href="http://www.tldp.org/LDP/intro-linux/html/chap_04.html" accesskey="U">Up</a></td><td valign="top" width="33%" align="right">Managing processes</td></tr></tbody></table></div></body></html>